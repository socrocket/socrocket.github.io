<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Doxygen 1.8.7">
    <meta name="author" content="meyer@c3e.cs.tu-bs.de">
    <title>SoCRocket: Interconnect Methodology</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="style-doxygen.css" rel="stylesheet" type="text/css" />
    <link href="bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="bootstrap-theme.min.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="highlight.pack.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen2bootstrap.js"></script>
    <link href="style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body class="mainpage">
    <div class="container">
      <header class="jumbotron masthead">
        <div class="inner">
          <h1>
            <img alt="Logo" src="socrocket-logo.png"/>
            SoCRocket
          </h1>
          <p>Transaction-Level Modeling Framework for Space Applications</p>
        </div>
      </header>
    </div>
  <div class="container" id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Interconnect Methodology </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#interconnect_methodology_ahb">AHB Modeling</a><ul><li class="level2"><a href="#im_ahb_payload">AHB Payload</a></li>
<li class="level2"><a href="#im_ahb_protocol">AHB Protocol mapping</a></li>
<li class="level2"><a href="#im_ahb_features">Not supported or partially supported features</a></li>
<li class="level2"><a href="#im_ahb_creating">Creating/Binding AHB sockets</a></li>
</ul>
</li>
<li class="level1"><a href="#interconnect_methodology_apb">APB Modeling</a><ul><li class="level2"><a href="#im_apb_payload">APB Payload</a></li>
<li class="level2"><a href="#im_apb_mapping">APB Protocol mapping</a></li>
<li class="level2"><a href="#im_apb_creating">Creating/Binding APB sockets</a></li>
</ul>
</li>
<li class="level1"><a href="#interconnect_methodology_axi">AXI Modeling</a></li>
</ul>
</div>
<div class="textblock"><p>This document is the Interconnect Methodology Summary of the SystemC Co-Simulation SoC Validation Platform (SoCRocket). It describes the IP interconnect infrastructure of the library, particularly the modeling of the AMBA protocol at loosely timed and approximately timed levels of abstraction.</p>
<p>Almost all components of the library are equipped with an AMBA interface. At TLM level these interfaces are represented by sockets, which are customized for interchanging payload of a certain format. The AMBA sockets used for modeling the SoCRocket communication interfaces are supplied by a TLM AMBA Modeling Kit, which has been developed under the roof of GreenSoCs. The kit is distributed by Carbon Design Systems Inc. and can be freely downloaded and used.</p>
<h1><a class="anchor" id="interconnect_methodology_ahb"></a>
AHB Modeling</h1>
<p>The AHB protocol is modeled at loosely timed and approximately timed level of abstraction. Focus is on high-level, functionally accurate transaction modeling. Low-level signals such as, for example, channel handshakes are not important at this level. Modeling the AHB protocol at transaction level requires a customized payload (<a class="el" href="interconnect_methodology.html#im_ahb_payload">AHB Payload</a>) and a mapping of TLM phases to protocol synchronization points (<a class="el" href="interconnect_methodology.html#im_ahb_protocol">AHB Protocol Mapping</a>).</p>
<h2><a class="anchor" id="im_ahb_payload"></a>
AHB Payload</h2>
<p>For modeling AHB bus communication transfer information is either mapped to fields of the TLM generic payload or to a sub-set of the payload extensions provided by the Carbon/GreenSoCs TLM AMBA Modeling Kit (Table 2).</p>
<table class="doxtable">
<tr>
<th><b>AHB Signal</b> </th><th><b>Description</b> </th><th><b>Mapping</b>  </th></tr>
<tr>
<td>HMASTER </td><td>ID of the AHB master the initializes the transaction </td><td>amba_ext::amba_ID </td></tr>
<tr>
<td>HADDR </td><td>Target address of the transaction </td><td>tlm_generic_payload::address </td></tr>
<tr>
<td>HTRANS </td><td>Type of current transfer: nonseq, seq, busy </td><td>Burst implicitly identified by length of payload.tlm_generic_payload::data_length </td></tr>
<tr>
<td>HWRITE </td><td>Write or read transfer </td><td>tlm_generic_payload::tlm_command </td></tr>
<tr>
<td>HSIZE </td><td>Size of the transfer in bytes </td><td>tlm_generic_payload::data_length </td></tr>
<tr>
<td>HBURST </td><td>Type of burst (e.g. incremental, wrapping) </td><td>Burst implicitly identified by length of payload.tlm_generic_payload::data_length </td></tr>
<tr>
<td>HPROT </td><td>Protection against illegal transactions </td><td>cacheability: amba_ext::cacheablenot supported: instr/data access, normal/privileged access, bufferable </td></tr>
<tr>
<td>HWDATA </td><td>Write data </td><td>tlm_generic_payload::data_ptr </td></tr>
<tr>
<td>HRDATA </td><td>Read data </td><td>tlm_generic_payload::data_ptr </td></tr>
<tr>
<td>HRESP </td><td>Transfer response </td><td>tlm_generic_payload::tlm_response </td></tr>
<tr>
<td>HLOCK </td><td>Indicates that master requires locked access to bus </td><td>amba_ext::lock </td></tr>
<tr>
<td>HSPLIT </td><td>Indicates split transfer </td><td>not supported </td></tr>
<tr>
<td>HREADY </td><td>Target ready to receive/send data </td><td>Low cycles are modeled by delaying BEGIN_RESP </td></tr>
<tr>
<td>HVALID </td><td>Initiator ready to receive/send data </td><td>Low cycles are modeled by delaying END_RESP </td></tr>
</table>
<p><b>Table 2 - AHB TLM payload mapping</b></p>
<h2><a class="anchor" id="im_ahb_protocol"></a>
AHB Protocol mapping</h2>
<h4>LT Abstraction</h4>
<p>At LT abstraction AHB transfers are modeled using plain TLM 2.0 blocking transfer calls (b_transport). The initiator starts the transaction at the beginning of the AHB address phase. The delay of the interconnect components and the target is aggregated in the transaction and returned to the initiator. The initiator is responsible for synchronization and may or may not decide to run ahead of time.</p>
<h4>AT Abstraction</h4>
<p>At AT abstraction AHB transfers are modeling using four timing points. The timing points relate to the phases to the TLM 2.0 standard protocol. However, in order to model timing in a more accurate way one additional phase transition was required. In following we will explain all relevant use cases in detail.</p>
<p><b>AHB write/read transfer (single)</b></p>
<p> 
<DIV class="row">
<DIV class="col-md-6">
</p>
<p>Figure 1 shows the TLM phase assignment for a single-beat write transfer:</p>
<ul>
<li>Initiator sends BEGIN_REQ at beginning of AHB address phase</li>
<li>Target sends END_REQ at the end of the AHB address phase (address sampled by slave)</li>
<li>Target sends BEGIN_RESP at the beginning of the AHB data phase; corresponds to HREADY becoming high (slave ready - wait states over). The delay of BEGIN_RESP should also reflect the wait states produced by the target during the data phase (not just the once before accepting the first data item).</li>
<li>Initiator sends END_RESP at the end of the AHB data phase. END_RESP must be delayed by the number of cycles VALID was low (transmission delayed by master).</li>
</ul>
<p> 
</DIV>
<DIV class="col-md-6">
</p>
<div class="image">
<img src="ahb_at_timing_single.svg" alt="ahb_at_timing_single.svg"/>
<div class="caption">
Figure 1 - AHB write transfer (single)</div></div>
<p>  
</DIV>
</DIV>
</p>
<p><b>AHB read burst</b></p>
<p> 
<DIV class="row">
<DIV class="col-md-6">
</p>
<p>Figure 2 shows the phase protocol mapping for an AHB read burst:</p>
<ul>
<li>The initiator sends BEGIN_REQ at the beginning of the AHB address phase</li>
<li>The target will send BEGIN_RESP at the beginning of the AHB data phase. BEGIN_RESP is delayed by the number of wait states. This includes both: the wait states before delivering the first data item and the intermediate wait states inserted during transfer (target blocking).</li>
<li>Because address phase and data phase overlap during an AHB burst transfer, END_REQ will usually be send after BEGIN_RESP. END_REQ marks the end of the AHB address phase. It relates to the time when the target samples the last address of the burst.</li>
<li>The initiator sends END_RESP at the end of the AHB data phase. END_RESP will be delayed by the number of initiator stall cycles (VALID low).</li>
</ul>
<p> 
</DIV>
<DIV class="col-md-6">
</p>
<div class="image">
<img src="ahb_at_timing_burst.svg" alt="ahb_at_timing_burst.svg"/>
<div class="caption">
Figure 2 - AHB read/write burst</div></div>
<p>  
</DIV>
</DIV>
</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000010">Todo:</a></b></dt><dd>maybe split up the graphic in read and write?</dd></dl>
<p><b>AHB write burst</b></p>
<p>The synchronization points of AHB write bursts are similar to AHB read bursts. So writing can also bee seen in Figure 2:</p>
<ul>
<li>The initiator sends BEGIN_REQ at the beginning of the AHB address phase.</li>
<li>The target sends BEGIN_RESP at the time the first data item is sampled, delayed by the total number of wait states involved in the transactions (cycles HREADY is low). This includes both: the wait states before delivering the first data item and the intermediate wait states inserted during transfer (target blocking).</li>
<li>Because address phase and data phase overlap during an AHB burst transfer, END_REQ will usually be send after BEGIN_RESP. END_REQ marks the end of the AHB address phase. It relates to the time when the target samples the last address of the burst.</li>
<li>The initiator sends END_RESP at the end of the AHB data phase. END_RESP will be delayed by the number of initiator stall cycles (VALID low).</li>
</ul>
<h2><a class="anchor" id="im_ahb_features"></a>
Not supported or partially supported features</h2>
<p>The model does not support early burst termination.</p>
<p>In case of a data split the slave is supposed to delay BEGIN_RESP. The arbiter (ahbctrl) will not use the additional delay to schedule another master.</p>
<h2><a class="anchor" id="im_ahb_creating"></a>
Creating/Binding AHB sockets</h2>
<p>The easiest way to create custom components with AHB sockets is to inherit from one of the AHB modeling base classes: <a class="el" href="classAHBMaster.html">AHBMaster</a>, <a class="el" href="classAHBSlave.html">AHBSlave</a>. The procedure is explained in detail in the SoCRocket <a class="el" href="modeling.html">User Manual</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000011">Todo:</a></b></dt><dd>verify section</dd></dl>
<p>For manual instantiation include header amba.h from Carbon TLM AMBA modeling kit.</p>
<p><b>Master socket declaration (single):</b></p>
<div class="fragment"><div class="line">amba::amba_master_socket&lt;32&gt; ahb;</div>
</div><!-- fragment --><p><b>Instantiation (module constructor):</b></p>
<div class="fragment"><div class="line">ahb(<span class="stringliteral">&quot;ahb&quot;</span>, amba::amba_AHB, ambaLayer, <span class="keyword">false</span>);</div>
<div class="line"><span class="preprocessor"># ambaLayer = amba::amba_AT or amba::amba_LT</span></div>
<div class="line"><span class="preprocessor"># false is only used for CT modeling</span></div>
</div><!-- fragment --><p><b>Slave socket declaration (single):</b></p>
<div class="fragment"><div class="line">amba::amba_slave_socket&lt;32&gt; ahb;</div>
</div><!-- fragment --><p><b>Instantiation (module constructor):</b></p>
<div class="fragment"><div class="line">ahb(<span class="stringliteral">&quot;ahb&quot;</span>, amba::amba_AHB, ambaLayer, <span class="keyword">false</span>);</div>
<div class="line"><span class="preprocessor"># ambaLayer = amba::amba_AT or amba::amba_LT</span></div>
<div class="line"><span class="preprocessor"># false is only used for CT modeling</span></div>
</div><!-- fragment --><p><b>Multi-master socket declaration:</b></p>
<div class="fragment"><div class="line">amba::amba_master_socket&lt;32, N&gt; ahbIN;</div>
<div class="line"><span class="preprocessor"># N: Number of channels for this socket - 0 meaning no limit</span></div>
</div><!-- fragment --><p><b>Instantiation (module constructor):</b></p>
<div class="fragment"><div class="line">ahbIN(<span class="stringliteral">&quot;ahbIN&quot;</span>, amba::amba_AHB, ambaLayer, <span class="keyword">false</span>)</div>
<div class="line"><span class="preprocessor"># ambaLayer = amba::amba_AT or amba::amba_LT</span></div>
<div class="line"><span class="preprocessor"># false is only used for CT modeling</span></div>
</div><!-- fragment --><p><b>Multi-slave socket declaration:</b></p>
<div class="fragment"><div class="line">amba::amba_slave_socket&lt;32, N&gt; ahbOUT;</div>
<div class="line"><span class="preprocessor"># N: Number of channels for this socket - 0 meaning no limit</span></div>
</div><!-- fragment --><p><b>Instantiation (module constructor):</b></p>
<div class="fragment"><div class="line">ahbOUT(<span class="stringliteral">&quot;ahbOUT&quot;</span>, amba::amba_AHB, ambaLayer*, <span class="keyword">false</span>**)</div>
<div class="line"><span class="preprocessor"># ambaLayer = amba::amba_AT or amba::amba_LT</span></div>
<div class="line"><span class="preprocessor"># false is only used for CT modeling</span></div>
</div><!-- fragment --><p><b>Binding sockets:</b></p>
<p>Binding AHB sockets follows the rules for TLM2.0 socket binding.</p>
<div class="fragment"><div class="line">initiator.ahb(target.ahb)</div>
</div><!-- fragment --><p>See <a class="el" href="leon3mp_2sc__main_8cpp.html">core/platforms/leon3mp/sc_main.cpp</a> for more examples.</p>
<h1><a class="anchor" id="interconnect_methodology_apb"></a>
APB Modeling</h1>
<p>The APB protocol is modeled at loosely timed level of abstraction. Focus is on high-level, functionally accurate transaction modeling. Low-level signals such as, for example, channel handshakes are not important at this level. Modeling the APB protocol at transaction level requires a customized payload (<a class="el" href="interconnect_methodology.html#im_apb_payload">APB Payload</a>) and adequate target delay estimation (<a class="el" href="interconnect_methodology.html#im_apb_mapping">APB Protocol mapping</a>).</p>
<h2><a class="anchor" id="im_apb_payload"></a>
APB Payload</h2>
<p>For modeling APB bus communication transfer information is either mapped to fields of the TLM generic payload or to a sub-set of the payload extensions provided by the Carbon/GreenSoCs TLM AMBA Modeling Kit (Table 3).</p>
<table class="doxtable">
<tr>
<th>APB Signal </th><th>Description </th><th>Mapping  </th></tr>
<tr>
<td>PADDR </td><td>Target address of transfer </td><td>tlm_generic_payload::address </td></tr>
<tr>
<td>PSEL/PENABLE </td><td>Bridge selects slave (decoder signal) </td><td>not required </td></tr>
<tr>
<td>PWRITE </td><td>Read or write operation </td><td>tlm_generic_payload::tlm_command </td></tr>
<tr>
<td>PWDATA </td><td>Write data </td><td>tlm_generic_payload::data_ptr </td></tr>
<tr>
<td>PRDATA </td><td>Read data </td><td>tlm_generic_payload::data_ptr </td></tr>
<tr>
<td>PREADY </td><td>Target ready to deliver data (extension of data phase) </td><td>Implicitly modeled Target increments transactions delay in blocking transport. </td></tr>
</table>
<p><b>Table 3 - APB TLM payload mapping</b></p>
<h2><a class="anchor" id="im_apb_mapping"></a>
APB Protocol mapping</h2>
<p>The APB protocol is intended for low-bandwidth communication with I/O components or memory mapped control registers. In contrast to AHB or AXI, APB is not pipelined and can therefore be sufficiently modeled using blocking communication.</p>
<p> 
<DIV class="row">
<DIV class="col-md-6">
</p>
<p>Figure 4 shows a simple APB write transfer and its abstraction using a blocking transport call:</p>
<ul>
<li>The initiator calls b_transport at TLM start.</li>
<li>The target will instantly return the aggregated component and setup delays (2 cycles).</li>
<li>The initiator receives the delay a blocks the bus.</li>
<li>The next transaction may not be issued before TLM end.</li>
</ul>
<p> 
</DIV>
<DIV class="col-md-6">
</p>
<div class="image">
<img src="ahb_apb_timing.svg" alt="ahb_apb_timing.svg"/>
<div class="caption">
Figure 4 - APB blocking transport delay</div></div>
<p>  
</DIV>
</DIV>
</p>
<h2><a class="anchor" id="im_apb_creating"></a>
Creating/Binding APB sockets</h2>
<p>The easiest way to create custom APB components is to instantiate a GreenReg socket. GreenReg sockets are extended AMBA sockets, which allow the specification of register interfaces.</p>
<p>Please include the amba.h header of the Carbon AMBA TLM Modeling Kit and the greenreg_ambasockets.h header in your design.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000012">Todo:</a></b></dt><dd>verify section</dd></dl>
<p>A detailed description on how to set up APB components and register interfaces is given in the SoCRocket <a class="el" href="modeling.html">User Manual</a>.</p>
<p><b>Master socket declaration (single):</b></p>
<div class="fragment"><div class="line"><a class="code" href="classgs_1_1reg_1_1greenreg__socket.html">gs::reg::greenreg_socket&lt;gs::amba::amba_slave&lt;32&gt;</a> &gt; apb;</div>
</div><!-- fragment --><p><b>Instantiation (module constructor):</b></p>
<div class="fragment"><div class="line">apb(<span class="stringliteral">&quot;apb&quot;</span>,</div>
<div class="line"><a class="code" href="satcan_8c.html#ae9180927c9b0d45c75dff89eb717b257">r</a>,                            <span class="comment">// Name of GreenReg register container</span></div>
<div class="line">APBDevice::get_base_addr_(),  <span class="comment">// APB base address</span></div>
<div class="line">APBDevice::get_size_(),       <span class="comment">// APB size of address space</span></div>
<div class="line">amba::amba_APB,               <span class="comment">// Bus protocol specifier</span></div>
<div class="line">amba::amba_LT,                <span class="comment">// APB is always LT (blocking)</span></div>
<div class="line"><span class="keyword">false</span>),                       <span class="comment">// Only used for CT modeling</span></div>
</div><!-- fragment --><h1><a class="anchor" id="interconnect_methodology_axi"></a>
AXI Modeling</h1>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000013">Todo:</a></b></dt><dd>is this needed? </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<footer>
  <div class="container">
    <div class="inner">
      <p>
        &nbsp; &copy; 
         <a href="http://www.tu-braunschweig.de/c3e">c3e - TU-Braunschweig</a>. 2012.
        All rights reserved. | <a href="impress.html">Impress</a> |
        Generated on Fri Dec 12 2014 14:22:22 for SoCRocket by &#160;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.7</a>
      </p>
    </div>
  </div>
</footer>
</body>
</html>

<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Doxygen 1.8.8">
    <meta name="author" content="meyer@c3e.cs.tu-bs.de">
    <title>SoCRocket: APBCtrl - AHB to APB Bridge</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="bootstrap-theme.min.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="highlight.pack.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen2bootstrap.js"></script>
    <link href="style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body class="mainpage">
    <div class="container">
      <header class="jumbotron masthead">
        <div class="inner">
          <h1>
            <img alt="Logo" src="socrocket-logo.png"/>
            SoCRocket
          </h1>
          <p>Transaction-Level Modeling Framework for Space Applications</p>
        </div>
      </header>
    </div>
  <div class="container" id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="usermanual.html">User Manual</a></li><li class="navelem"><a class="el" href="models_p.html">IP Models</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classAPBCtrl.html">APBCtrl</a> - AHB to APB Bridge </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#apbctrl_p1">Functionality and Features</a><ul><li class="level2"><a href="#apbctrl_p1_1">Overview</a></li>
<li class="level2"><a href="#apbctrl_p1_2">Address Decoding</a></li>
<li class="level2"><a href="#apbctrl_p1_3">Plug & Play Support</a></li>
<li class="level2"><a href="#apbctrl_p1_4">Power Monitoring</a></li>
</ul>
</li>
<li class="level1"><a href="#apbctrl_p2">Interface</a></li>
<li class="level1"><a href="#apbctrl_p3">Internal Structure</a><ul><li class="level2"><a href="#apbctrl_p3_1">Decoder initialization</a></li>
<li class="level2"><a href="#apbctrl_p3_2">LT behaviour</a></li>
<li class="level2"><a href="#apbctrl_p3_3">AT behaviour</a></li>
</ul>
</li>
<li class="level1"><a href="#apbctrl_p4">Compilation</a></li>
<li class="level1"><a href="#apbctrl_p5">Example Instantiation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="apbctrl_p1"></a>
Functionality and Features</h1>
<h2><a class="anchor" id="apbctrl_p1_1"></a>
Overview</h2>
<p>The APBCTRL TLM model can be used to simulate behavior and timing of the GRLIB APBCTRL AHB-to-APB Bridge VHDL IP. The model is available at two levels of abstractions (LT and AT). For modeling the APBCTRL we mostly follow the recommendations given in RD06. All details regarding APB protocol modeling at transaction level (payload structure, TLM phase mapping) can be found in the SoCRocket Interconnect Methodology [RD9].</p>
<h2><a class="anchor" id="apbctrl_p1_2"></a>
Address Decoding</h2>
<p>For address decoding the TLM APBCTRL uses the same arithmetic as the GRLIB VHDL model. Each APB slave provides a configuration record identifying its address range. This is done using two parameters: <code>paddr</code> and <code>pmask</code>. The <code>paddr</code> represents the 12bit APB base address of the device. The <code>pmask</code> parameter indicates the size of the address range. If <code>addr</code> is the 12 bit APB address (bits 20 â€“ 8 of absolute address) of a transaction following logic equation must be solved:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;select = (addr ^ paddr) &amp; pmask</div>
</div><!-- fragment --><p>Address addr falls in the range of the slave, if select equals zero.</p>
<h2><a class="anchor" id="apbctrl_p1_3"></a>
Plug &amp; Play Support</h2>
<p>The TLM APBCTRL supports the Plug &amp; Play (PNP) mechanism described in <em>RD04</em>. APB configuration records and access functions are implemented in class <a class="el" href="classAPBDevice.html">APBDevice</a>. Each slave connected to the APBCTRL must be derived from this class. The PNP information of the slaves is collected at <code>start_of_simulation()</code>. The combined information is mapped on a read-only area at the top 4kBytes of the bridge address space.</p>
<h2><a class="anchor" id="apbctrl_p1_4"></a>
Power Monitoring</h2>
<p>Power monitoring can be enabled by setting the constructor parameter <code>pow_mon</code> to <code>true</code>. The model is annotated with default power information that has been gathered using a generic 90nm Standard-Cell Library and statistical power estimation at Gate-Level.</p>
<p>The accuracy of the build-in power models and the default switching energy settings cannot be guaranteed. In order to achieve the best possible results the user is recommended to annotate the design with custom target-technology dependent power information.</p>
<p>The power model of the APBCTRL, all required parameters, and default settings are explained in the SoCRocket Power Modeling Report [RD11].</p>
<h1><a class="anchor" id="apbctrl_p2"></a>
Interface</h1>
<p>The GRLIB VHDL model of the APBCTRL is configured using Generics. For the implementation of the TLM model most of these Generics were refactored to constructor parameters of class <a class="el" href="classAPBCtrl.html">APBCtrl</a>. An overview about the available parameters is given in Table 13.</p>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Description  </th></tr>
<tr>
<td>nm </td><td>SystemC name of the module </td></tr>
<tr>
<td>haddr </td><td>The 12bit MSB address at the AHB bus </td></tr>
<tr>
<td>hmask </td><td>The 12bit address mask for the AHB bus </td></tr>
<tr>
<td>mcheck </td><td>Check if there are any intersections between APB slave memory regions </td></tr>
<tr>
<td>hindex </td><td>The AHB bus index </td></tr>
<tr>
<td>pow_mon </td><td>Enable power monitoring </td></tr>
<tr>
<td>ambaLayer </td><td>Coding style/abstraction of the model (LT or AT) </td></tr>
</table>
<p><em>Table 13 - APBCTRL Constructor Parameters</em></p>
<p>The system-level interface of the APBCTRL comprises an AHB slave socket (<code>ahb</code>) and an APB master socket (<code>apb</code>). The APB socket can be bound to multiple slaves (multi-socket), while the AHB socket may be bound to only one master. Depending on the constructor parameter <code>ambaLayer</code> the ahb socket is configured for blocking (LT) or non-blocking (AT) communication. The <code>ambaLayer</code> parameter has no effect on the apb socket. For the sake of performance the APB communication is modeled using blocking transport only. In case of LT configuration a TLM blocking transport function is registered at the ahb socket. For the AT abstraction the model provides a TLM non-blocking forward transport function. Additionally, the model contains a debug transport function for non-intrusive code execution (TRAP) and checking. The signatures of all transport functions are compliant with the TLM2.0 standard. Moreover, the module inherits SignalKit inputs for clock cycle time (<code>clk</code>) and reset (<code>rst</code>) from class <a class="el" href="classCLKDevice.html">CLKDevice</a>. <a class="el" href="classAPBCtrl.html">APBCtrl</a> is also derived from class <a class="el" href="classAHBDevice.html">AHBDevice</a>. Hence, it exposes a PNP configuration record, which is mapped into the configuration area of <a class="el" href="classAHBCtrl.html">AHBCtrl</a>.</p>
<h1><a class="anchor" id="apbctrl_p3"></a>
Internal Structure</h1>
<p>This section describes the internal structure of the <a class="el" href="classAPBCtrl.html">APBCtrl</a>. The class hierarchy of the model is flat. All functionality is comprised in class <a class="el" href="classAPBCtrl.html">APBCtrl</a>, which is described in the files <code>apbctrl.h</code> and <code><a class="el" href="apbctrl_8cpp.html">apbctrl.cpp</a></code>.</p>
<h2><a class="anchor" id="apbctrl_p3_1"></a>
Decoder initialization</h2>
<p>Similar to the AHBCTRL, the address decoder of the APBCTRL is based on a routing table implemented in form of a <code>std::map</code>. The <code>std::map APBCtrl::slave_map</code> is initialized in function <a class="el" href="group__apbctrl.html#ga5a2f71291cd55e51f8ba08e04c066d43" title="Set up slave map and collect plug & play information. ">APBCtrl::start_of_simulation()</a>. The function iterates through all slaves bound to socket <code>apb</code>. If the slave is a valid APB Device (must be derived from class <a class="el" href="classAPBDevice.html">APBDevice</a>) the module creates a new address entry in <code>APBCtrl::slave_map</code>. The function also copies the configurartion information of the attached slaves into a 32bit wide array (<code>mSlaves</code>). This array is mapped in the configuration area of the APBCTRL (as described in RD04), where any bus master can access it.</p>
<h2><a class="anchor" id="apbctrl_p3_2"></a>
LT behaviour</h2>
<p>Compared to AHB, APB is a rather simple protocol. From the perspective of an AHB bus master the APBCTRL is an ordinary slave device. The APBCTRL does not do any arbitration. Moreover, APB communication is not pipelined. Therefore, the <code>ambaLayer</code> constructor parameter only affects the AHB slave interface of the APBCTRL. The APB socket uses blocking communication.</p>
<p>Most of the behaviour of the APBCTRL is encapsulated in a single function (<code>APBCtrl::exec_decoder</code>). In LT mode this function is directly called from <code>b_transport</code>. The <code>exec_decoder</code> function first checks whether the incoming transaction is directed toward the configuration area or not. In the first case the <code><a class="el" href="group__apbctrl.html#ga0526b9a9d4259d84d11018c5a91a9855" title="Returns a PNP register from the APB configuration area (upper 4kb of address space) ...">APBCtrl::getPNPReg</a></code> function is used to access the APB configuration records (<code>APBCtrl::mSlaves</code>). The APB configuration area is read-only. Write operations cause a <code>TLM_COMMAND_ERROR_RESPONSE</code>. In the second case <code>APBCtrl::exec_decoder</code> calls <code><a class="el" href="group__apbctrl.html#ga4161d40d53d042a08ca9de52d250230b" title="Get slave index for a given address. ">APBCtrl::get_index</a></code>. The <code><a class="el" href="group__apbctrl.html#ga4161d40d53d042a08ca9de52d250230b" title="Get slave index for a given address. ">APBCtrl::get_index</a></code> function receives the address of the transaction as an input argument and returns the id of the slave binding (<code>index</code>). For this reason <code>get_index</code> iterates through the previously described <code>slave_map</code>. In case no slave can be found the function returns <code>-1</code>. This produces a <code>TLM::TLM_ADDRESS_ERROR_RESPONSE</code> and an error message will be written to <code>stdout</code>. In case of success the transaction is send to the identified slave by calling its <code><a class="el" href="classAHBSlave.html#ade8eddba2e309d2f8e30a87a0c20ab8c" title="TLM blocking transport functions. ">APBCtrl::b_transport</a></code> function:</p>
<div class="fragment"><div class="line">apb[index]-&gt;b_transport( *<a class="code" href="fft_8c.html#a261dc6445544ab3a09e5f50b961887b5">trans</a>, delay);</div>
</div><!-- fragment --><p>Since APBCTRL is a bus bridge, the payload event needs to be copied. In this process the segment address of the bridge (<code>haddr</code>) is removed from address field of the transaction.</p>
<p>The LT APBCTRL adds one cycle of delay to the transaction in order to approximate the delay of the APB setup phase. The delay may be consumed by the slave or added to the latency of the target. The LT APBCTRL does not synchronize with the SystemC kernel. The transaction delay is returned to the master, who is responsible for consuming the passed time.</p>
<h2><a class="anchor" id="apbctrl_p3_3"></a>
AT behaviour</h2>
<p>The AT mode is intended to more accurately approximate the timing of the GRLIB APBCTRL hardware model. This is achieved by respecting the pipelined nature of the AHB protocol. In AT mode the APBCTRL contains two SystemC threads. A routing table is not required, because the communication on the APB side is always blocking. Hence, no more than one transaction can be active on the APB at any time.</p>
<p>A new transaction arrives in <code>nb_transport_fw</code> with phase <code>BEGIN_REQ</code>. The function enters the transaction in the <code>mAcceptPEQ</code> payload event queue. After consumption of the component accept delay, <code>mAcceptPEQ</code> triggers the <code>acceptTXN</code> thread. The latter is responsible for sending <code>END_REQ</code> to the AHBCTRL. This is the signal for the AHBCTRL that the AHB address phase is completed.</p>
<p>In case of a read transaction, <code>acceptTXN</code> forwards the transaction to the <code>processTXN</code> thread (via the <code>mTransactionPEQ</code> payload event queue). <code>ProcessTXN</code> calls the <code>exec_decoder</code> function, which has already been described above (see LT behaviour). After the control has returned from the slave device, <code>processTXN</code> sends <code>BEGIN_RESP</code> on the backward path. Afterwards, the transaction is considered complete. An eventual <code>END_REQ</code> from the master will be ignored.</p>
<p>If the transaction indicates a write operation, the <code>mTransactionPEQ</code> is written from the <code>nb_transport_fw</code> function, after reception of <code>BEGIN_DATA</code>. This also triggers the <code>processTXN</code> thread and a call to <code>exec_decoder</code>. After return from <code>exec_decoder</code> <code>END_DATA</code> is send on the backward path. This completes the AHB data phase.</p>
<p>For more informationon about the AHB AT implementation please see RD09.</p>
<h1><a class="anchor" id="apbctrl_p4"></a>
Compilation</h1>
<p>For the compilation of the APBCTRL unit, a WAF <code>wscript</code> file is provided and integrated in the superordinate build mechanism of the library. All required objects for simulating the APBCTRL on platform level are compiled in a sub-library name apbctrl using following build command:</p>
<div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;./waf â€“target=apbctrl</div>
</div><!-- fragment --><p>To utilize <a class="el" href="classAPBCtrl.html">APBCtrl</a> in simulations with other components, add <a class="el" href="classAPBCtrl.html">APBCtrl</a> the use list of your <code>wscript</code>.</p>
<h1><a class="anchor" id="apbctrl_p5"></a>
Example Instantiation</h1>
<p>This example shows how to instantiate the module APBCTRL. The APBCTRL is a bridge between the AHB and the APB portion of the AMBA bus system. The component is created in lines 36-41. In line 46 the module is bound to the master socket of the AHBCTRL. Line 49 binds a slave, here the control interface of the MCTRL, to the master socket of the APBCTRL. Similar to the AHBCTRL the APBCTRL needs a notion of time. Hence, it inherits the clock interface of class <a class="el" href="classCLKDevice.html">CLKDevice</a>. In this examples the clock cycle time is set in line 55.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;<a class="code" href="common_2amba_8h.html">core/common/amba.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ahbctrl_8h.html">core/models/ahbctrl/ahbctrl.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="apbctrl_8h.html">core/models/apbctrl/apbctrl.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;genericmemory.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="mctrl_8h.html">core/models/mctrl/mctrl.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;testbench.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="systemc_8h.html">core/common/systemc.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacestd.html">std</a>;</div>
<div class="line"><span class="keyword">using namespace </span><a class="code" href="namespacesc__core.html">sc_core</a>;</div>
<div class="line"></div>
<div class="line"><span class="keyword">class </span>Top : <span class="keyword">public</span> sc_module {</div>
<div class="line">  <span class="keyword">public</span>:</div>
<div class="line"></div>
<div class="line">    <span class="comment">// *** DECLARE MODULES</span></div>
<div class="line"></div>
<div class="line">    <span class="comment">// Testbench master</span></div>
<div class="line">    Testbench testbench;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// AHB bus model</span></div>
<div class="line">    <a class="code" href="classAHBCtrl.html">AHBCtrl</a> ahbctrl;</div>
<div class="line"></div>
<div class="line">    <span class="comment">// APB Bridge</span></div>
<div class="line">    <a class="code" href="classAPBCtrl.html">APBCtrl</a> apbctrl;</div>
<div class="line"></div>
<div class="line">    ...</div>
<div class="line"></div>
<div class="line">    <span class="comment">// Constructor</span></div>
<div class="line">    Top(sc_module_name nm) : sc_module(nm),</div>
<div class="line"></div>
<div class="line">      ...</div>
<div class="line">      ahbctrl(<span class="stringliteral">&quot;ahbctrl&quot;</span>, 0xfff, 0xfff, 0xff0, 0xff0, 0, 0, 0, 0, 0, 1, 0, 0, amba::amba_LT),</div>
<div class="line"></div>
<div class="line">      apbctrl(<span class="stringliteral">&quot;apbctrl&quot;</span>,   <span class="comment">// SystemC name</span></div>
<div class="line">               0x800,      <span class="comment">// AHB base address</span></div>
<div class="line">               0xfff,      <span class="comment">// AHB address maks</span></div>
<div class="line">               <a class="code" href="dhry_8c.html#a41f9c5fb8b08eb5dc3edce4dcb37fee7">true</a>,       <span class="comment">// mcheck - Check consistency of address map</span></div>
<div class="line">               1,          <span class="comment">// hindex - AHB bus index</span></div>
<div class="line">               amba::amba_LT) {</div>
<div class="line"></div>
<div class="line">        ...</div>
<div class="line"></div>
<div class="line">        <span class="comment">// APB bridge to AHB bus</span></div>
<div class="line">        ahbctrl.<a class="code" href="classAHBCtrl.html#a622c97a190d69fffba226a5e8c72f8f1">ahbOUT</a>(apbctrl.<a class="code" href="classAHBSlave.html#a979b8a2794293164649e463b33b2cba5">ahb</a>);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Memory controller to APB bus</span></div>
<div class="line">        apbctrl.<a class="code" href="classAPBCtrl.html#a008feba42113f1de7d107063b1a0fe67">apb</a>(mctrl.apb);</div>
<div class="line"></div>
<div class="line">        ..</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Set clock</span></div>
<div class="line">        ahbctrl.<a class="code" href="group__utils.html#ga1e502b9a84a32054d08a28935f19283b">set_clk</a>(10,SC_NS);</div>
<div class="line">        apbctrl.<a class="code" href="group__utils.html#ga1e502b9a84a32054d08a28935f19283b">set_clk</a>(10,SC_NS);</div>
<div class="line"></div>
<div class="line">    }</div>
<div class="line"></div>
<div class="line">    <span class="keyword">virtual</span> ~Top() {}</div>
<div class="line">};</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<footer>
  <div class="container">
    <div class="inner">
      <p>
        &nbsp; &copy; 
         <a href="http://www.tu-braunschweig.de/c3e">c3e - TU-Braunschweig</a>. 2012.
        All rights reserved. | <a href="impress.html">Impress</a> |
        Generated on Wed Oct 22 2014 10:58:41 for SoCRocket by &#160;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.8</a>
      </p>
    </div>
  </div>
</footer>
</body>
</html>

<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Doxygen 1.8.7">
    <meta name="author" content="meyer@c3e.cs.tu-bs.de">
    <title>SoCRocket: MCtrl - Memory Controller</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="style-doxygen.css" rel="stylesheet" type="text/css" />
    <link href="bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="bootstrap-theme.min.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="highlight.pack.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen2bootstrap.js"></script>
    <link href="style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body class="mainpage">
    <div class="container">
      <header class="jumbotron masthead">
        <div class="inner">
          <h1>
            <img alt="Logo" src="socrocket-logo.png"/>
            SoCRocket
          </h1>
          <p>Transaction-Level Modeling Framework for Space Applications</p>
        </div>
      </header>
    </div>
  <div class="container" id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="usermanual.html">User Manual</a></li><li class="navelem"><a class="el" href="models_p.html">IP Models</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">MCtrl - <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> Controller </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#mctrl_functionality">Functionality and Features</a><ul><li class="level2"><a href="#mctrl_control_register">Control Registers</a></li>
<li class="level2"><a href="#mctrl_address_space">Address Space</a></li>
<li class="level2"><a href="#mctrl_prom_access">PROM Access</a></li>
<li class="level2"><a href="#mctrl_local_io_access">Local I/O Access</a></li>
<li class="level2"><a href="#mctrl_sram_access">SRAM Access</a></li>
<li class="level2"><a href="#mctrl_sdram_access">SDRAM Access</a></li>
<li class="level2"><a href="#mctrl_sdream_modes">SDRAM Modes of Operation</a></li>
<li class="level2"><a href="#mctrl_power_modeling">Power Modeling</a></li>
</ul>
</li>
<li class="level1"><a href="#mctrl_interface">Interface</a></li>
<li class="level1"><a href="#mctrl_internal_structure">Internal Structure</a><ul><li class="level2"><a href="#mctrl_decoder_initialization">Decoder initialization</a></li>
<li class="level2"><a href="#mctrl_lt_behaviour">LT behaviour</a></li>
<li class="level2"><a href="#mctrl_at_behaviour">AT behaviour</a></li>
</ul>
</li>
<li class="level1"><a href="#mctrl_compilation">Compilation</a></li>
<li class="level1"><a href="#mctrl_example_instantiantion">Example Instantiation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="mctrl_functionality"></a>
Functionality and Features</h1>
<p>The TLM model of the MCTRL unit models behaviour and timing of the GRLIB MCTRL VHDL implementation described in RD04. It controls a memory subsystem comprising four different types of memory: PROM, I/O, SRAM, and SDRAM. All these memories can be accessed through an AHB slave socket, using an internal address decoder. The control register interface of the device is modeled as a GreenReg register bank, which is attached to an APB slave socket. Hence, like any other device containing GreenReg registers, class mctrl is derived from class gr_device (3.4).</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000024">Todo:</a></b></dt><dd>what about this section 3.4 (memory mapped registers)?</dd></dl>
<p>The MCTRL is a slave on the AHB bus and on the APB bus. Respectively, it inherits PNP configuration records from classes <a class="el" href="classAHBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">AHBDevice</a> and <a class="el" href="classAPBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">APBDevice</a>. The timing of the model is approximated at two different levels of abstraction (LT and AT).</p>
<h2><a class="anchor" id="mctrl_control_register"></a>
Control Registers</h2>
<p>The register control interface consists of four configuration registers (Table 14). All of them are 32 bits wide.</p>
<table class="doxtable">
<tr>
<th>APB Address Offset </th><th>Register  </th></tr>
<tr>
<td>0x00 </td><td>MCFG1 (PROM and I/O) </td></tr>
<tr>
<td>0x04 </td><td>MCFG2 (RAM) </td></tr>
<tr>
<td>0x08 </td><td>MCFG3 (SDRAM Refresh Period) </td></tr>
<tr>
<td>0x0C </td><td>MCFG4 (Power Saving Configuration) </td></tr>
</table>
<p><b>Table 14 – MCTRL Registers</b></p>
<p><a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> configuration register 1 is used to program the timing of rom and local I/O accesses.</p>
<p><a class="anchor" id="mctrl_mcfg1"></a></p><table  class="register_view">
<caption align="bottom"><a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> Configuration Register 1 (MCFG1)</caption>
<tr>
<th class="begin">31 </th><th></th><th class="end">29 </th><th class="begin">28 </th><th class="end">27 </th><th class="bit">26 </th><th class="bit">25 </th><th></th><th class="begin">23 </th><th></th><th></th><th class="end">20 </th><th class="bit">19 </th><th class="begin">18 </th><th></th><th></th><th></th><th></th><th></th><th class="end">12 </th><th class="bit">11 </th><th></th><th class="begin">9 </th><th class="end">8 </th><th class="begin">7 </th><th></th><th></th><th class="end">4 </th><th class="begin">3 </th><th></th><th></th><th class="end">0 </th></tr>
<tr>
<td colspan="3">RESERVED </td><td colspan="2">IOBUSW </td><td colspan="1">IBRDY </td><td colspan="1">BEXCN </td><td colspan="1" class="empty">&#160; </td><td colspan="4">IOWS </td><td colspan="1">IOEN </td><td colspan="7">RESERVED </td><td colspan="1">PWEN </td><td colspan="1" class="empty">&#160; </td><td colspan="2">PROMWIDTH </td><td colspan="4">PROM WWS </td><td colspan="4">PROM RWS </td></tr>
</table>
<table  class="register_list">
<caption align="bottom"><a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> Configuration Register 1 (MCFG1) Description</caption>
<tr class="register_list_header">
<th class="register_table_bits">Bits</th><th>Id</th><th>Description </th></tr>
<tr>
<td>31 - 29</td><td>RESERVED</td><td>Reserved Bits  </td></tr>
<tr>
<td>28 - 27</td><td>IOBUSW</td><td>I/O bus width – Sets the data width of the I/O area (00–8bit, 01–16bit, 10–32bit)  </td></tr>
<tr>
<td>26</td><td>IBRDY</td><td>I/O bus ready enable – Enables bus ready signalling for the I/O area.  </td></tr>
<tr>
<td>25</td><td>BEXCN</td><td>Bus error enable – Enables bus error signalling.  </td></tr>
<tr>
<td>23 - 20</td><td>IOWS</td><td>I/O waitstates – Sets the number of waitstates during I/O access (0-15)  </td></tr>
<tr>
<td>19</td><td>IOEN</td><td></td></tr>
<tr>
<td>18 - 12</td><td>RESERVED</td><td>Reserved Bits  </td></tr>
<tr>
<td>11</td><td>PWEN</td><td>PROM write enable – Enables write cycles to the PROM area  </td></tr>
<tr>
<td>9 - 8</td><td>PROMWIDTH</td><td>Data width of the PROM area (00-8bit, 0-16bit, 10-32bit)  </td></tr>
<tr>
<td>7 - 4</td><td>PROM WWS</td><td>PROM write waitstates (0-15)  </td></tr>
<tr>
<td>3 - 0</td><td>PROM RWS</td><td>PROM read waitstates (0-15)  </td></tr>
</table>
<p><br />
 <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> configuration register 2 is used to control the timing of the SRAM and SDRAM.</p>
<p><a class="anchor" id="mctrl_mcfg2"></a></p><table  class="register_view">
<caption align="bottom"><a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> Configuration Register 2 (MCFG2)</caption>
<tr>
<th class="bit">31 </th><th class="bit">30 </th><th class="begin">29 </th><th></th><th class="end">27 </th><th class="bit">26 </th><th class="begin">25 </th><th></th><th class="end">23 </th><th class="begin">22 </th><th class="end">21 </th><th class="begin">20 </th><th class="end">19 </th><th class="bit">18 </th><th class="bit">17 </th><th class="bit">16 </th><th class="bit">15 </th><th class="bit">14 </th><th class="bit">13 </th><th class="begin">12 </th><th></th><th></th><th class="end">9 </th><th></th><th class="bit">7 </th><th class="bit">6 </th><th class="begin">5 </th><th class="end">4 </th><th class="begin">3 </th><th class="end">2 </th><th class="begin">1 </th><th class="end">0 </th></tr>
<tr>
<td colspan="1">SDRF </td><td colspan="1">TRP </td><td colspan="3">TRFC </td><td colspan="1">TCAS </td><td colspan="3">SDRAM BANKSZ </td><td colspan="2">SDRAM COLSZ </td><td colspan="2">SD CMD </td><td colspan="1">D64 </td><td colspan="1">RESERVED </td><td colspan="1">MS </td><td colspan="1">RESERVED </td><td colspan="1">SE </td><td colspan="1">SI </td><td colspan="4">RAM BANK SIZE </td><td colspan="1" class="empty">&#160; </td><td colspan="1">RBRDY </td><td colspan="1">RMW </td><td colspan="2">RAM WIDTH </td><td colspan="2">RAM WWS </td><td colspan="2">RAM RWS </td></tr>
</table>
<table  class="register_list">
<caption align="bottom"><a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> Configuration Register 2 (MCFG2) Description</caption>
<tr class="register_list_header">
<th class="register_table_bits">Bits</th><th>Id</th><th>Description </th></tr>
<tr>
<td>31</td><td>SDRF</td><td>SDRAM refresh – Enables SDRAM refresh  </td></tr>
<tr>
<td>30</td><td>TRP</td><td>SDRAM tRP will be equal to 2 or 3 system clocks (0/1)  </td></tr>
<tr>
<td>29 - 27</td><td>TRFC</td><td>SDRAM tRFC will be equal to 3+field_value system clocks  </td></tr>
<tr>
<td>26</td><td>TCAS</td><td>SDRAM CAS delay 2 or 3 cycles (0/1). Also sets tRCD  </td></tr>
<tr>
<td>25 - 23</td><td>SDRAM BANKSZ</td><td>SDRAM bank size – Sets the bank size for SDRAM chip selects (000 – 4 MB, 001 – 8 MB, … 111 – 512 MB)  </td></tr>
<tr>
<td>22 - 21</td><td>SDRAM COLSZ</td><td>SDRAM column size (00 – 256, 01 – 512, 10 – 1024, 11 – 4096)  </td></tr>
<tr>
<td>20 - 19</td><td>SD CMD</td><td>SDRAM command – (01 – PRECHARGE, 10 – AUTO-REFRESH, 11 – LOAD-CMD)  </td></tr>
<tr>
<td>18</td><td>D64</td><td>SDRAM data bit is 64 bit wide (0/1)  </td></tr>
<tr>
<td>17</td><td>RESERVED</td><td></td></tr>
<tr>
<td>16</td><td>MS</td><td>Mobile SDR support enabled (0/1)  </td></tr>
<tr>
<td>15</td><td>RESERVED</td><td></td></tr>
<tr>
<td>14</td><td>SE</td><td>SDRAM enable – Enables SDRAM (0/1)  </td></tr>
<tr>
<td>13</td><td>SI</td><td>SRAM disable – Disables SRAM if SE is set to 1.  </td></tr>
<tr>
<td>12 - 9</td><td>RAM BANK SIZE</td><td>Sets the size of each SRAM bank (0000 – 8kb, 0001 – 16kb, 1111 – 256 MB)  </td></tr>
<tr>
<td>7</td><td>RBRDY</td><td>Enables bus ready signalling for the SRAM area  </td></tr>
<tr>
<td>6</td><td>RMW</td><td>Enables read-modify-write cycles for sub-word writes to 16bit or 32bit areas  </td></tr>
<tr>
<td>5 - 4</td><td>RAM WIDTH</td><td>Sets the data width of the SRAM area (00 – 8, 01 – 16, 1X – 32)  </td></tr>
<tr>
<td>3 - 2</td><td>RAM WWS</td><td>Sets the number of wait states for SRAM read cycles (0 – 3)  </td></tr>
<tr>
<td>1 - 0</td><td>RAM RWS</td><td>Sets the number of wait states for SRAM write cycles (0 – 3)  </td></tr>
</table>
<p><br />
 MCFG3 is dedicated to SDRAM control and MCFG4 to power saving options (see <a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a>).</p>
<h2><a class="anchor" id="mctrl_address_space"></a>
Address Space</h2>
<p>The address space is divided in the three partitions: PROM, I/O, and RAM. The division of the address space is static and cannot be modified after initialization of the MCTRL unit. In the VHDL implementation, the different parts of the address space are calculated from generics, which are implemented as constructor parameters in the TLM module.</p>
<p>The PROM address space is derived from the parameters romaddr and rommask , which define the start address and the size of the PROM address space. The romaddr is written to the 12 bit-wide ADDR field of the <a class="el" href="classAHBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">AHBDevice</a> BAR0 register of the MCTRL. The rommask is written to the 12 bit-wide MASK field of the <a class="el" href="classAHBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">AHBDevice</a> BAR0 register. The PROM address space is byte-addressable and has an address width of 32 bit.</p>
<p>The size of the PROM address space is:</p>
<p>(212 – MASK ) MByte</p>
<p>The address space is divided into two PROM banks of equal size.</p>
<p>The local I/O address space is calculated in the same way as the PROM address space. All calculations are based on the ioaddr and iomask parameters. The only difference to PROM is that no memory banks are defined.</p>
<p>The SRAM address space is derived from the ramaddr and rammask parameters. Again calculations are very similar to PROM and IO. Although, the partitioning of the resulting address space depends on the settings in the MCFG2 register. The register provides the fields SDRAM enable ( SE ) and SRAM disable( SI ) indicating the presence of SRAM, SDRAM, or SRAM &amp; SDRAM. If the SE bit is low, SI has no effect.</p>
<p>for details and information on the organization of the SRAM address space, regarding the number of banks, bank locations, bank sizes, and – in case of SDRAM – number of row and column address bits, see the <a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a>. Examples for possible partitionings of the RAM address space (default size of 1 GByte) are given in Figure 2.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000025">Todo:</a></b></dt><dd>add address space figure</dd></dl>
<p><b>Figure 2 – RAM address space</b></p>
<p>The default configuration is the SRAM only configuration (Config 1). The entire RAM address space can be split into up to five SRAM banks. The number of SRAM banks is defined by the constructor parameter srbanks. By default four SRAM banks are configured. Banks 1-4 are always located in the lower half of the RAM address space. Their size is variable between 8 KByte – 256 MByte. It can be set using the RAM BANK SIZE field ( RAM BS ) of the MCFG2 register. If the bank size exceeds 128 MByte, the number of banks must be reduced or the size of the address space must be increased. In the SRAM only configuration, a fifth bank can be attached to take up the upper half of the RAM address space.</p>
<p>In the second configuration (Config 2) both SRAM and SDRAM are enabled. In this case, the lower half of the RAM address space is populated by up to 4 SRAM banks. SRAM bank 5 cannot be present, because two SDRAM banks are mapped to the upper half of the RAM address space. The size of the SDRAM banks is scalable between 4 MByte – 512 MByte, according to the SDRAM BANKSZ field of the MCFG2 register. If the SDRAM bank size exceeds 256 MByte, i.e. if the SDRAM bank size is set to 512MByte, the RAM address space needs to be extended to the size of 2GByte to fit the SDRAM in the upper half of the RAM address space. As this will also extend the SRAM address space to 1GByte giving room for the maximum number of four SRAM banks of the maximum supported size of 256 MByte, a size of 2GByte represents the maximum sensible RAM address space. Such a configuration would be reflected by rammask 0x800.</p>
<p>In the SDRAM only configuration (Config 3), the SDRAM banks are mapped into the lower half of the RAM address space. If the SDRAM bank size is set to 512MByte, the RAM address space needs to be extended to the size of 2GByte. The upper half of the address space remains reserved and unused.</p>
<p>In any configuration, the initial bank sizes are calculated to be the maximum possible size, which can be deduced from address space size and number of banks.</p>
<p>It is possible to switch between the three configurations shown in Figure 2 by overwriting the respective bits in the MCFG2 register. In such an event the MCTRL recalculates the start and end addresses of all SRAM and SDRAM memory banks. Because only the address decoding changes, the content of the memories is not affected. However, the bus master must take care to read from the correct memory banks after having caused a reorganization of the RAM address space. The bus master also has to take care of not exceeding the RAM address space when changing the SRAM or SDRAM bank size. If, for example, the RAM address space is 1GByte and the size of four SRAM banks is dynamically switched from 128 MByte to 256 GByte, the SRAM banks will take up the SDRAM address space, causing an overlap of SRAM and SDRAM device addresses. Due to the SystemC code structure, any access to SDRAM would then be redirected to SRAM causing system malfunction.</p>
<p>The way the MCTRL TLM model handles memory access depends on the type of memory addressed. This information is extracted by evaluating the target address. In the default case the delay of a transaction is fully modeled in the MCTRL unit, which holds information about all timing parameters involved. The timing parameters are given in the configuration registers. Additional delay information can be deduced from the streaming width and data length, in case of burst transactions. Optionally, the IORBY ( MCFG1 ) and RBRBY ( MCFG2 ) may be used to obtain additional timing information from the attached memory models and simulate bus-ready-signalling. All delay values are calculated as multiples of the bus clock period.</p>
<h2><a class="anchor" id="mctrl_prom_access"></a>
PROM Access</h2>
<p>In case of PROM, write access needs to be explicitly allowed by setting the PWEN bit of the MCFG1 register. Forbidden write operations, will be cancelled and produce a TLM_COMMAND_ERROR_RESPONSE as well as an error message printed to std::out.</p>
<p>A read access to PROM memory requires 4 bus cycles plus 0 – 15 wait states. A write access to PROM memory takes 3 bus cycles plus 0 – 15 wait states. The wait states can be configured via the PROM READ WS and PROM WRITE WS fields of the MCFG1 register. The attached PROM memory may have a data width of 8, 16 or 32 bits. This must be reflected by the settings in the PROM WIDTH field of MCFG1 . If the PROM WIDTH field is set to 16 or 8 bits, a read access to PROM will still result in loading a full 32 bit word from memory. The word will be transmitted in a burst of two half-words or four single bytes, adding a delay of two bus cycles (data1 and data2) in 16 bit mode or six bus cycles (3x data1 and 3x data2) in 8 bit mode.</p>
<h2><a class="anchor" id="mctrl_local_io_access"></a>
Local I/O Access</h2>
<p>The local I/O area supports access to 32 bit words, 16 bit half-words, and single bytes. A read access takes 4 bus cycles (lead-in, data1, data2, lead-out) and a write access takes 3 bus cycles (lead-in, data, lead-out). For both, read and write operations, the model provides a mechanism for dynamic <em>bus-ready-signaling</em>, which can induce an arbitrary number of wait states. It is the task of the attached I/O device to model this delay and add it to the delay parameter of the TLM transport function. The MCTRL unit will observe the delay parameter and add its value to the overall transaction delay.</p>
<h2><a class="anchor" id="mctrl_sram_access"></a>
SRAM Access</h2>
<p>The access to SRAM is similar to the PROM access, the difference being the number of wait states (0 – 3). For a read access, the number of wait states can be set via the RAM READ WS field of the MCFG2 register. Read accesses to SRAM bank 5 and write accesses to SRAM support dynamic wait states in the VHDL model. Similar to the dynamic <em>bus-ready-signaling</em> in the I/O area, it is the task of the TLM memory device to add this delay to the delay variable of the TLM transaction.</p>
<h2><a class="anchor" id="mctrl_sdram_access"></a>
SDRAM Access</h2>
<p>In the VHDL model of the MCTRL SDRAM is accessed over a separate bus, if the sepbus parameter is set to one. This bus can have a width of 32 or 64 bit, as indicated by the D64 field of the MCFG2 register. For TLM communication this architectural detail (separate bus) is not relevant. However, the D64 bit is taken into account for delay calculation, because it affects the streaming width to and from memory.</p>
<p>At TLM level it is also not necessary to model the SDRAM commands, which are emitted by the SDRAM controller. It is only important to estimate the impact of the different command sequences on the memory access time. This especially accounts for opening and closing memory rows for read and write access. The delay of an ACTIVATE command is added to any operation that needs to buffer a new SDRAM row. Closing a row comes at the cost of the delay contributed by a PRECHARGE command.</p>
<p>A read access to SDRAM is always performed as a page burst access. Because a page bursts can be interrupted by a PRECHARGE command, it is possible to read an arbitrary number of data words. In the TLM model, the data length field of the generic payload can hence be set to any multiple of the SDRAM word length. The delay will be calculated for opening the row, sending one data word each clock cycle, and closing the row again. If the requested sequence of words starts at the end of a row and ends in the next row, the time for opening and closing the second row will be added.</p>
<p>The time required for opening a row is determined by the TCAS field of the MCFG2 register. If the TCAS field is changed, a real hardware memory device would require a notification. In the RTL model this is done by sending LMR command. In the TLM model, the MCTRL unit models the timing of each transaction and expects the memory model to behave correctly, i.e. an LMR command would not have any functional effect. Hence, the LMR command is not issued, but its delay is modeled by adding it to the next transaction.</p>
<p>A write access to SDRAM is always performed as a single word write, i.e. burst mode is not supported. A requested write burst from the bus will be transformed into a burst of writes.</p>
<p>To retain data in memory, refresh cycles are required. The MCTRL unit only supports devices capable of AUTO REFRESH, i.e. MCTRL only needs to periodically trigger the refresh, which is then organized by the memory internally. In the TLM implementation, the refresh has no functional effect, but influences the overall operational speed of the memory device. The model keeps track of the refresh period and locks the SDRAM for the duration of one refresh cycle after each refresh period. If an access to the SDRAM device is requested while SDRAM is locked, the transaction will be stalled for the rest of the refresh cycle. The other way round, a refresh can also be stalled by a transaction.</p>
<h2><a class="anchor" id="mctrl_sdream_modes"></a>
SDRAM Modes of Operation</h2>
<p>The MCTRL unit can configure the SDRAM device to operate in several modes. The various operation modes relate to different power saving options. Operation modes can be enabled using the <b>mobile</b> constructor parameter.</p>
<p>On system start, SDRAM is always initialized for "normal operation". The initialization sequence of the hardware model is emulated by adding delay to the first transaction.</p>
<p>In case mobile memory is not supported ( <code>mobile = '0'</code> ) the MS field of MCFG2 is set to zero. This disables the power saving features exposed by the MCFG4 register of the device. If the mobile parameter is set to one, mobile memory is supported, but disabled by default. The MS field of the MCFG2 register is set to one, but the ME field of the MCFG4 register is set to zero. None of the settings in MCFG4 has any effect as long ME is disabled. For <code>mobile = '2'</code> , mobile memory is supported and enabled by default. For <code>mobile = '3'</code> , mobile memory cannot be disabled, i.e. the ME field of MCFG4 becomes read only.</p>
<p>If mobile memory is enabled, the SDRAM device supports the following power saving modes: Power Down, Self-Refresh, Partial Array Self Refresh, and Deep Power Down. The actual mode can be selected by writing the PMODE field of MCFG4.</p>
<h3>Normal Operation Mode</h3>
<p>In normal operation mode, the memory access functions as described in section <a class="el" href="mctrl_p.html#mctrl_sram_access">SRAM Access</a>. In case of a change in the operation mode, a hardware SDRAM memory would require to be reconfigured. This would be done using the LOAD_EXTENDED_MODE_REGISTER (EMR) command. Like the LMR command, EMR does not have any functional effect. Moreover, the impact of EMR on the timing is neglectable. Therefore, at TLM-level EMR is ignored.</p>
<h3>Power Down Mode</h3>
<p>To enter power down mode, mobile memory must be enabled and the PMODE field of the MCFG4 register must be changed to "001". In power down mode, the input and output buffers of the SDRAM device are deactivated after an idle period of 16 clock cycles. The buffers can be woken up within one clock cycle at any time. Respectively, each TLM memory access requires an additional delay of one bus clock cycle.</p>
<h3>Self-Refresh Mode</h3>
<p>If the system is powered down, mobile SDRAM can retain its content by switching into self-refresh mode. Entering self-refresh mode is induced by setting the PMODE field of the MCFG4 register to "010".</p>
<p>In self-refresh mode the system is supposed to be shut down. Therefore, no accesses to memory are expected (despite theoretically possible). For TLM requests in self-refresh mode a warning will be send to std::out.</p>
<h3>Partial Array Self-Refresh Mode</h3>
<p>In partial array self-refresh mode parts of the memory can be retained during power down. The mode is entered by setting the three-bit-wide PASR field of the MCFG4 register to a value not equal to zero.</p>
<p>The partial array can be defined as the half, quarter, eighth, or sixteenth part of the memory ( PASR = 001, 010, 101, or 110). lt is always associated to the lower bound of the SDRAM address space.</p>
<p>Entering partial array self-refresh mode immediately erases all parts of the TLM SDRAM memory, which are outside of the refresh array.</p>
<h3>Deep Power Down Mode</h3>
<p>To enter deep power down mode, mobile memory must be enabled and the PMODE field of the MCFG4 register must be changed to "101". Thereafter, the content of the SDRAM memory is immediately deleted.</p>
<p>During deep powe down mode all accesses to SDRAM produce a TLM_ADDRESS_ERROR_RESPONSE.</p>
<p>Deep power down mode can be left by changing the PMODE field of MCFG4 to any other mode of operation.</p>
<h2><a class="anchor" id="mctrl_power_modeling"></a>
Power Modeling</h2>
<p>Power monitoring can be enabled by setting the constructor parameter pow_mon to true. The model is annotated with default power information that has been gathered using a generic 90nm Standard-Cell Library and statistical power estimation at Gate-Level.</p>
<p>The accuracy of the build-in power models and the default switching energy settings cannot be guaranteed. In order to achieve the best possible results the user is recommended to annotate the design with custom target-technology dependent power information.</p>
<p>The power model of the MCTRL, all required parameters, and default settings are explained in the SoCRocket Power Modeling Report.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000026">Todo:</a></b></dt><dd>add the power modeling report?</dd></dl>
<h1><a class="anchor" id="mctrl_interface"></a>
Interface</h1>
<p>The GRLIB VHDL model of the MCTRL is configured using Generics. For the implementation of the TLM model most of these Generics were refactored to constructor parameters of class mctrl. An overview about the available parameters is given in Table 17.</p>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Function </th><th>Allowed Range </th><th>Default  </th></tr>
<tr>
<td>name </td><td>SystemC name of the module </td><td></td><td></td></tr>
<tr>
<td>romasel </td><td>log2(PROM address space size) - 1. E.g. If size of the PROM area is 0x20000000 romasel is:log2(2^29)-1 = 28. </td><td>0 – 31 </td><td>28 </td></tr>
<tr>
<td>sdrasel </td><td>log2(RAM address space size) - 1. E.g If size of the RAM area is 0x40000000 sdrasel is: log2(2^30)-1= 29. </td><td>0 – 31 </td><td>29 </td></tr>
<tr>
<td>romaddr </td><td>ADDR field of BAR0 defining PROM address space. </td><td>0 – 0xFFF </td><td>0x000 </td></tr>
<tr>
<td>rommask </td><td>MASK field of BAR0 defining PROM address space size. rommask = PROM address space size in MByte </td><td>0 – 0xFFF </td><td>0xE00 </td></tr>
<tr>
<td>ioaddr </td><td>similar to romaddr </td><td>0 – 0xFFF </td><td>0x200 </td></tr>
<tr>
<td>iomask </td><td>similar to rommask </td><td>0 – 0xFFF </td><td>0xE00 </td></tr>
<tr>
<td>ramaddr </td><td>similar to romaddr </td><td>0 – 0xFFF </td><td>0x400 </td></tr>
<tr>
<td>rammask </td><td>similar to rommask </td><td>0 – 0xFFF </td><td>0xC00 </td></tr>
<tr>
<td>paddr </td><td>ADDR field of the APB <a class="el" href="classBAR.html">BAR</a> configuration registers address space </td><td>0 – 0xFFF </td><td>0x000 </td></tr>
<tr>
<td>pmask </td><td>MASK field of the APB <a class="el" href="classBAR.html">BAR</a> configuration registers address space </td><td>0 – 0xFFF </td><td>0xFFF </td></tr>
<tr>
<td>wprot </td><td>RAM write protection </td><td>0 – 1 </td><td>0 </td></tr>
<tr>
<td>srbanks </td><td>Number of SRAM banks </td><td>0 – 5 </td><td>4 </td></tr>
<tr>
<td>ram8 </td><td>Enable 8 bit PROM and SRAM access </td><td>0 – 1 </td><td>0 </td></tr>
<tr>
<td>ram16 </td><td>Enable 16 bit PROM and SRAM access </td><td>0 – 1 </td><td>0 </td></tr>
<tr>
<td>sden </td><td>Enable SDRAM controller </td><td>0 – 1 </td><td>0 </td></tr>
<tr>
<td>sepbus </td><td>SDRAM is located on separate bus </td><td>0 – 1 </td><td>1 </td></tr>
<tr>
<td>sdbits </td><td>32 or 64 bit SDRAM data bus </td><td>24, 64 </td><td>32 </td></tr>
<tr>
<td>mobile </td><td>Enable Mobile SDRAM support0: Mobile SDR is not supported1: Mobile SDR is supported but disabled2: Mobile SDR is supported and default3: Mobile SDR support only </td><td>0 – 3 </td><td>0 </td></tr>
<tr>
<td>hindex </td><td>AHB slave index </td><td>0 - NAHBSLV–1 </td><td>0 </td></tr>
<tr>
<td>pindex </td><td>APB slave index </td><td>0 - NAPBSLV–1 </td><td>0 </td></tr>
<tr>
<td>pow_mon </td><td>Enable power monitoring </td><td>0 – 1 </td><td>0 </td></tr>
<tr>
<td>ambaLayer </td><td>TLM abstraction/coding style </td><td>LT/AT </td><td>LT </td></tr>
</table>
<p><b>Table 17 – MCTRL Constructor Parameters</b></p>
<p>The system-level interface of the TLM MCTRL comprises an AHB slave socket ( ahb ), an APB slave socket ( apb ) and a GreenSocks initiator multi-socket ( mem ). The AHB socket is intended to be bound to the TLM model of the AHBCTRL. The APB socket must be connected to the TLM model of the APBCTRL. The mem socket may be connected to any device implementing the memdevice memory interface (3.2). The SoCRocket library provides a generic memory complying with this condition (7). It can be used as a ROM, I/O, SRAM or SDRAM device.</p>
<p>Depending on the constructor parameter abstrLayer the AHB socket is configured for blocking (LT) or non-blocking (AT) communication. The APB socket is blocking transport (LT) only - indepent of abstrLayer. In the LT case the MCTRL registers two TLM blocking transport functions: one for ahb and one for apb. For the AT abstraction the model provides a TLM non-blocking forward transport function for the AHB socket and a blocking transport function for the APB socket. Additionally, the model contains debug transport functions for both sockets. The signatures of all transport functions are compliant with the TLM2.0 standard.</p>
<p>Next to the TLM sockets the model comes with SignalKit inputs for clock cycle time ( clk ) and reset ( rst ). Both of them are inherited from class <a class="el" href="classCLKDevice.html">CLKDevice</a> , which is shared amongst most of the models in the library.</p>
<h1><a class="anchor" id="mctrl_internal_structure"></a>
Internal Structure</h1>
<p>This section describes the internal structure of the MCTRL. A basic overview is given in Figure 3. The class hierarchy of the model is flat. All functionality is comprised in class mctrl , which is described in the files mctrl.h and <a class="el" href="mctrl_8cpp.html">mctrl.cpp</a>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000027">Todo:</a></b></dt><dd>add figure</dd></dl>
<p><b>Figure 3 – Structure of the TLM MCTRL</b></p>
<h2><a class="anchor" id="mctrl_decoder_initialization"></a>
Decoder initialization</h2>
<p>The internal address decoder represents the central behaviour of the MCTRL. The decoder decides how and under which conditions a transaction from the AHB socket is forwarded to one of the connected slave memories.</p>
<p>Before the start of a simulation the decoder must be initialized. This is done in two steps using SystemC callbacks. First, in the end_of_elaboration function, the memory mapped registers are created, bound and initialized. Afterwards, the start_of_simulation function iterates through all memories bound to the mem socket extracting their configuration information. This is done using the member functions of the memorydevice interface. The start_of_simulation function updates the settings of the MCTRL control registers and creates one PNP base address register entry per memory device ( BAR0-3 ). At simulation time the address information in the <a class="el" href="classBAR.html">BAR</a> records is the base for routing the TLM transactions from the ahb socket to the memories.</p>
<h2><a class="anchor" id="mctrl_lt_behaviour"></a>
LT behaviour</h2>
<p>In LT mode the constructor of the MCTRL registers a blocking transport function ( b_transport ) at the ahb slave socket. All payload objects arriving in b_transport are directly forwarded to the functional part of the model, which is encapsulated in function exec_func.</p>
<p>The exec_func function receives the payload object and the transaction delay pointer as input parameters. At the beginning of the function the payload is extracted. Address, length and data pointer are locally copied. In the next step the address is decoded using the get_ports function. Get_ports compares the address of the transaction with the settings in the decoder registers ( BAR0-3 ). It returns an object of type MEMPort. In case no slave could be found the MCTRL generates a TLM_ADDRESS_ERROR_RESPONSE and an error message. In the following a set of checks is performed to ensure the characteristics of the access are compatible with the addressed memory device. It is checked whether e.g. the transfer length of the transaction is compatible with the memory width, read-modify-write cycles must be inserted or if the targeted memory region is writeable (e.g. PROM). Please see the source code documentation for more detailed information. If one of the constraints is not met, the MCTRL generates a TLM_GENERIC_ERROR_RESPONSE.</p>
<p>Afterwards, the MCTRL calculates the base delay for transfering one word of data to the selected memory ( word_delay ) and the delay offset, which might be involved in the transaction ( trans_delay – e.g. for opening a SDRAM row). The calculations have various dependencies. For PROM, I/O and SRAM the number of wait-states are encoded in MCFG1 and MCFG2. The parameters for the SDRAM timing can be found in MCFG2 and MCFG3 ( TRP, TRFC, TCAS,… ). For mobile SDRAM, additional delay is accumulated for Power Down and Partial Array Self Refresh Mode. Operations directed to memory in Deep Power Down Mode create a TLM_GENERIC_ERROR_RESPONSE.</p>
<p>In the following exec_func creates and initializes a new generic payload. Thereby, the global target address is transformed into an absolute address for the selected memory. The communication between MCTRL and memory is always blocking:</p>
<div class="fragment"><div class="line"><a class="code" href="satcan_8c.html#aacc30ddef90709c5957406a45a0c8678">mem</a>[port_id]-&gt;b_transport(memgp, mem_delay);</div>
</div><!-- fragment --><p>If bus-ready signalling is enabled (IBRDY, RBRDY) the calculation of the actual transfer delay is left to the memory ( mem_delay ). Otherwise, mem_delay is ignored and the final delay is calculated using the transfer base delays ( word_delay , trans_delay ), the transfer length, the memory width and the clock cycle time.</p>
<p>After return from exec_func the model calls wait to consume the component delay. Optionally, this task can be shifted to the bus master.</p>
<h2><a class="anchor" id="mctrl_at_behaviour"></a>
AT behaviour</h2>
<p>The AT mode is intended to more accurately approximate the timing of the GRLIB MCTRL. This is achieved by modeling the pipelined nature of the AHB protocol, which allows address phase and data phase of consequtive transactions to overlap. The MCTRL registers two SC_THREAD s to support that feature: acceptTXN and processTXN. Moreover, it provides a TLM non-blocking forward transport function ( nb_transport_fw ). The operation of the module in AT-mode can be best understood by following the control flow of a transaction.</p>
<p>A new transaction arrives in nb_transport_fw with phase BEGIN_REQ. The function enters the transaction in the mAcceptPEQ payload event queue and returns to the caller with TLM_ACCEPTED. The mAcceptPEQ triggers the acceptTXN thread. In case of a read transaction acceptTXN directly copies the payload in the mTransactionPEQ - for notification of thread processTXN. Write transactions are not send to processTXN , before their data pointer becomes valid. This is ackknowledged by the master via a BEGIN_DATA on the forward path.</p>
<p>The processTXN thread calls the functional interface of the MCTRL, which is encapsulated in function exec_func. The behaviour of exec_func has already been described in 6.3.2. After return from exec_func the processTXN thread actives the busy flag, before consuming the accumulated component delay. The busy flag is used by thread acceptTXN in order to check whether a transaction is in progress. As long as the busy flag is true, new transactions are blocked. This means, they are accepted by nb_transport_fw , but will not receive END_REQ.</p>
<p>After unblocking acceptTXN ( busy=false, unlock_event ) the processTXN thread sends BEGIN_RESP for read transactions and END_DATA for write transactions. A final END_RESP on the forward path will be ignored.</p>
<h1><a class="anchor" id="mctrl_compilation"></a>
Compilation</h1>
<p>For the compilation of the MCTRL unit, a WAF wscript is provided and integrated in the superordinate build mechanism of the libary.</p>
<p>All required objects for simulating the MCTRL on platform level are compiled in a sub-library name mctrl using following command: </p><pre class="fragment">$ ./waf –target=mctrl
</pre><p>For using the MCTRL in simulations with other component add <b>mctrl</b> to the use list of your WAF <b>wscript</b>.</p>
<h1><a class="anchor" id="mctrl_example_instantiantion"></a>
Example Instantiation</h1>
<p>An example is given in section 7.5, which jointly demonstrates the instantiation of MCTRL and GenericMemory.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000028">Todo:</a></b></dt><dd>section generic memory systemc model hinzufuegen und verlinken </dd></dl>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<footer>
  <div class="container">
    <div class="inner">
      <p>
        &nbsp; &copy; 
         <a href="http://www.tu-braunschweig.de/c3e">c3e - TU-Braunschweig</a>. 2012.
        All rights reserved. | <a href="impress.html">Impress</a> |
        Generated on Fri Nov 28 2014 15:12:30 for SoCRocket by &#160;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.7</a>
      </p>
    </div>
  </div>
</footer>
</body>
</html>

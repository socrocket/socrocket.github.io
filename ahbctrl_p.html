<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Doxygen 1.8.7">
    <meta name="author" content="meyer@c3e.cs.tu-bs.de">
    <title>SoCRocket: AHBCtrl - AHB Controler</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="bootstrap-theme.min.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="highlight.pack.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen2bootstrap.js"></script>
    <link href="style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body class="mainpage">
    <div class="container">
      <header class="jumbotron masthead">
        <div class="inner">
          <h1>
            <img alt="Logo" src="socrocket-logo.png"/>
            SoCRocket
          </h1>
          <p>Transaction-Level Modeling Framework for Space Applications</p>
        </div>
      </header>
    </div>
  <div class="container" id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="usermanual.html">User Manual</a></li><li class="navelem"><a class="el" href="models_p.html">IP Models</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classAHBCtrl.html">AHBCtrl</a> - AHB Controler </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ahbctrl_p1">Functionality and Features</a><ul><li class="level2"><a href="#ahbctrl_p1_1">Overview</a></li>
<li class="level2"><a href="#ahbctrl_p1_2">Address Decoding</a></li>
<li class="level2"><a href="#ahbctrl_p1_3">Arbitration</a></li>
<li class="level2"><a href="#ahbctrl_p1_4">Plug & Play Support</a></li>
<li class="level2"><a href="#ahbctrl_p1_5">Snooping</a></li>
<li class="level2"><a href="#ahbctrl_p1_6">Power Monitoring</a></li>
</ul>
</li>
<li class="level1"><a href="#ahbctrl_p2">Interface</a></li>
<li class="level1"><a href="#ahbctrl_p3">Internal Structure</a><ul><li class="level2"><a href="#ahbctrl_p3_1">Decoder initialization</a></li>
<li class="level2"><a href="#ahbctrl_p3_2">LT behaviour</a></li>
<li class="level2"><a href="#ahbctrl_p3_3">AT behaviour</a></li>
</ul>
</li>
<li class="level1"><a href="#ahbctrl_p4">Compilation</a></li>
<li class="level1"><a href="#ahbctrl_p5">Example Instantiation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ahbctrl_p1"></a>
Functionality and Features</h1>
<h2><a class="anchor" id="ahbctrl_p1_1"></a>
Overview</h2>
<p>The AHBCTRL TLM model can be used to simulate behavior and timing of the GRLIB AHB Controller VHDL IP. The model is available at two levels of abstractions (LT and AT). All details regarding AHB protocol modeling at transaction level (payload structure, TLM phase mapping) can be found in the <a class="el" href="interconnect_methodology.html#interconnect_methodology_ahb">SoCRocket Interconnect Methodology</a>.</p>
<h2><a class="anchor" id="ahbctrl_p1_2"></a>
Address Decoding</h2>
<p>For address decoding the TLM AHBCTRL uses the same arithmetic as the GRLIB VHDL model. Each slave in the system provides a configuration record identifying its address range. This is done using two parameters: <code>haddr</code> and <code>hmask</code>. The <code>haddr</code> parameter represents the 12bit MSB base address of the device. The <code>hmask</code> parameter indicates the size of the address range. If <code>addr</code> is the 12 bit MSB address of a transaction following logic equation must be solved:</p>
<div class="fragment"><div class="line">select = (addr ^ haddr) &amp; hmask</div>
</div><!-- fragment --><p>Address <code>addr</code> falls in the address range of the slave if <code>select</code> equals zero.</p>
<h2><a class="anchor" id="ahbctrl_p1_3"></a>
Arbitration</h2>
<p>At AT abstraction the AHBCTRL supports two modes of arbitration: round robin and priority based. Arbitration mode can be selected by setting the <code>rrobin</code> constructor parameter. In fixed priority mode (<code>rrobin = 0</code>), the bus request priority is equal to the masters’s bus index: the lower the index, the higher the priority. In round robin mode, priority is rotated one step after each AHB transfer. This is implemented as a modulo counter, which can be found in function <code>AHBCtrl::arbitrate_me</code>.</p>
<h2><a class="anchor" id="ahbctrl_p1_4"></a>
Plug &amp; Play Support</h2>
<p>The TLM AHBCTRL supports the Plug &amp; Play (PNP) mechanism described in <a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a>. AHB configuration records and access functions are implemented in class <code><a class="el" href="classAHBDevice.html">AHBDevice</a></code>. Each master and slave to be connected to the bus model must be derived from this class. The PNP information of the slaves is collected at <code>AHBCtrl::start_of_simulation</code> (<a class="el" href="ahbctrl_p.html#ahbctrl_p1_3">Arbitration</a>). The combined information is mapped to the address range defined by the constructor parameters <code>cfgaddr</code> and <code>cfgmask</code>. By default, this relates to addresses <code>0xfffff000 – 0xffffffff</code>. The master information is placed in the first 2kB block and the slave information in the second 2kB block of the device. For internal use all master information is aligned in integer array <code>mMasters</code>, while slave information can be found in <code>mSlaves</code>.</p>
<h2><a class="anchor" id="ahbctrl_p1_5"></a>
Snooping</h2>
<p>The TLM AHBCTRL supports dbus snooping. Address, length and master id of any write access will be broadcasted through the SignalKit output <a class="el" href="classAHBCtrl.html#a6ca95414d9137fcea01c48877c73bea0" title="Broadcast of master_id and write address for dcache snooping. ">AHBCtrl::snoop</a>. In LT mode this is done in the blocking transport function (<code><a class="el" href="group__ahbctrl.html#ga8d737345a2659702b7fcb8129f21b29f" title="TLM blocking transport method. ">AHBCtrl::b_transport</a></code>), which is registered at socket <code><a class="el" href="classAHBCtrl.html#ab5e9fbf1d4e20ad7b9c1305d7e1fc915" title="AHB slave multi-socket. ">AHBCtrl::ahbIN</a></code>. The AT mode implements snooping within the <code>SC_THREAD</code> <code>AHBCtrl::DataThread</code>. The <code>DataThread</code> is triggered by the non-blocking transport forward function (<code>nb_transport_fw</code>) on reception of phase <code>BEGIN_DATA</code>. The snooping information can be broadcasted to all relevant bus masters, by binding the snoop output of the ahbctrl to multiple snooping inputs (similar to multi-socket). The example below shows how to connect the snooping signal to four instances of type <a class="el" href="classmmu__cache.html" title="Top-level class of the memory sub-system for the TrapGen LEON3 simulator. ">mmu_cache</a>:</p>
<div class="fragment"><div class="line"><span class="comment">// Connect snooping (broadcast)</span></div>
<div class="line">ahbctrl.<a class="code" href="classAHBCtrl.html#a6ca95414d9137fcea01c48877c73bea0">snoop</a>(cache0.snoop);</div>
<div class="line">ahbctrl.<a class="code" href="classAHBCtrl.html#a6ca95414d9137fcea01c48877c73bea0">snoop</a>(cache1.snoop);</div>
<div class="line">ahbctrl.<a class="code" href="classAHBCtrl.html#a6ca95414d9137fcea01c48877c73bea0">snoop</a>(cache2.snoop);</div>
<div class="line">ahbctrl.<a class="code" href="classAHBCtrl.html#a6ca95414d9137fcea01c48877c73bea0">snoop</a>(cache3.snoop);</div>
</div><!-- fragment --><h2><a class="anchor" id="ahbctrl_p1_6"></a>
Power Monitoring</h2>
<p>Power monitoring can be enabled by setting the constructor parameter <code>pow_mon</code> to <code>true</code>. The model is annotated with default power information that has been gathered using a generic 90nm Standard-Cell Library and statistical power estimation at Gate-Level. The accuracy of the built-in power models and the default switching energy settings cannot be guaranteed. In order to achieve the best possible results the user is recommended to annotate the design with custom target-technology dependent power information.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000019">Todo:</a></b></dt><dd>is this power modeling report still accurate?</dd></dl>
<p>The power model of the AHBCTRL, all required parameters, and default settings are explained in the SoCRocket Power Modeling Report (RD11).</p>
<h1><a class="anchor" id="ahbctrl_p2"></a>
Interface</h1>
<p>The GRLIB VHDL model of the AHBCTRL is configured using Generics. For the implementation of the TLM model most of these Generics were refactored to constructor parameters of class <a class="el" href="classAHBCtrl.html">AHBCtrl</a>. An overview about the available parameters is given in Table 12.</p>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Description  </th></tr>
<tr>
<td>nm </td><td>SystemC name </td></tr>
<tr>
<td>ioaddr </td><td>The 12bit MSB address of the AHB I/O area </td></tr>
<tr>
<td>iomask </td><td>The 12bit address mask of the AHB I/O area </td></tr>
<tr>
<td>cfgaddr </td><td>The 12bit MSB address of the AHB configuration area (PNP) </td></tr>
<tr>
<td>cfgmask </td><td>The 12bit address mask of the AHB configuration area (PNP) </td></tr>
<tr>
<td>rrobin </td><td>Arbitration mode: 1 – round robin, 0 – priorities (AT only) </td></tr>
<tr>
<td>split </td><td>Enables AHB SPLIT response (AT only) </td></tr>
<tr>
<td>defmast </td><td>ID of the default master </td></tr>
<tr>
<td>ioen </td><td>Enable AHB I/O area </td></tr>
<tr>
<td>fixbrst </td><td>Enable support for fixed-length bursts </td></tr>
<tr>
<td>fpnpen </td><td>Enable full decoding of PNP configuration records </td></tr>
<tr>
<td>mcheck </td><td>Check if there are any intersections between core memory regions. </td></tr>
<tr>
<td>pow_mon </td><td>Enable power monitoring </td></tr>
<tr>
<td>ambaLayer </td><td>Coding style/abstraction of model (LT or AT) </td></tr>
</table>
<p><em>Table 12 - AHBCTRL Constructor Parameters</em></p>
<p>The system-level interface of the TLM AHBCTRL comprises an AHB master (<code><a class="el" href="classAHBCtrl.html#a622c97a190d69fffba226a5e8c72f8f1" title="AHB master multi-socket. ">AHBCtrl::ahbOUT</a></code>) and an AHB slave socket (<code><a class="el" href="classAHBCtrl.html#ab5e9fbf1d4e20ad7b9c1305d7e1fc915" title="AHB slave multi-socket. ">AHBCtrl::ahbIN</a></code>). Both of them enable the connection to multiple masters and slaves (multi-sockets). Depending on the constructor parameter <code>ambaLayer</code> the sockets are configured for blocking (LT) or non-blocking (AT) communication. In the LT case the module registers a TLM blocking transport function at <code>ahbIN</code>. For the AT abstraction the model provides a TLM non-blocking forward transport function for the <code>ahbIN</code> socket and a TLM non-blocking backward transport function for the <code>ahbOUT</code> socket. In any case the model registers a TLM debug transport function. Within the current release of the library, debug transport is mainly used for non-intrusive code execution from the LEON-ISS. The signatures of all transport functions are compliant with the TLM2.0 standard.</p>
<p>Next to the TLM sockets the model comes with SignalKit inputs for clock cycle time (<code><a class="el" href="classCLKDevice.html#a63aa004a943e94879ba209b818ca17bd" title="Clock input signal. ">AHBCtrl::clk</a></code>) and reset (<code><a class="el" href="classCLKDevice.html#ad7286de2647cc8b936ff9544c8cc31c0" title="Reset input signal. ">AHBCtrl::rst</a></code>), as well as a SignalKit output for snooping (<code><a class="el" href="classAHBCtrl.html#a6ca95414d9137fcea01c48877c73bea0" title="Broadcast of master_id and write address for dcache snooping. ">AHBCtrl::snoop</a></code>). The <code><a class="el" href="classCLKDevice.html#a63aa004a943e94879ba209b818ca17bd" title="Clock input signal. ">AHBCtrl::clk</a></code> and <code><a class="el" href="classCLKDevice.html#ad7286de2647cc8b936ff9544c8cc31c0" title="Reset input signal. ">AHBCtrl::rst</a></code> inputs are inherited from class <code><a class="el" href="classCLKDevice.html">CLKDevice</a></code>, while <code><a class="el" href="classAHBCtrl.html#a6ca95414d9137fcea01c48877c73bea0" title="Broadcast of master_id and write address for dcache snooping. ">AHBCtrl::snoop</a></code> is directly defined in <code><a class="el" href="classAHBCtrl.html">AHBCtrl</a></code>.</p>
<h1><a class="anchor" id="ahbctrl_p3"></a>
Internal Structure</h1>
<p>This section describes the internal structure of the AHBCTRL. The class hierarchy of the model is flat. All functionality is comprised in class <code><a class="el" href="classAHBCtrl.html">AHBCtrl</a></code>, which is described in the files ahbctrl.h and <a class="el" href="ahbctrl_8cpp.html">ahbctrl.cpp</a>.</p>
<h2><a class="anchor" id="ahbctrl_p3_1"></a>
Decoder initialization</h2>
<p>The address decoder of the TLM AHBCTRL is based on a routing table implemented as a std::map. The std::map slave_map contains the index and address information of all the slaves connected to the AHBCTRL. It is initialized in function <code>AHBCtrl::start_of_simulation</code>. The function iterates through all slaves bound to socket <code><a class="el" href="classAHBCtrl.html#a622c97a190d69fffba226a5e8c72f8f1" title="AHB master multi-socket. ">AHBCtrl::ahbOUT</a></code>. If the slave is a valid AHB Device (must be derived from class <code><a class="el" href="classAHBDevice.html">AHBDevice</a></code>) the module creates one address entry in slave_map per base address register (<a class="el" href="classBAR.html">BAR</a>). There can be at most four sub-devices/BARs per slave. If the constructor parameter fpenen is enabled, the start_of_simulation function also copies the PNP information of any connected module (masters and slaves) into two 32bit wide arrays (mSlaves / mMasters). These arrays are mapped into the configuration area of the AHBCTRL (as described in <a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a>), where they can be accessed by any bus master.</p>
<h2><a class="anchor" id="ahbctrl_p3_2"></a>
LT behaviour</h2>
<p>In LT mode the AHBCTRL is a simple address decoder. All incoming transactions will be directly forwarded to their targets, without any arbitration done. The decoder is located in the b_transport function. Transactions may be directed to the internal configuration area (PNP) or to one of the connected slaves. The configuration area is read-only. For access to the slave memory range, <a class="el" href="group__ahbctrl.html#ga8d737345a2659702b7fcb8129f21b29f" title="TLM blocking transport method. ">AHBCtrl::b_transport</a> calls AHBCtrl::get_index. The get_index function receives the address of the transaction as an input argument and returns the id of the slave binding (index). For this reason get_index iterates through the previously described slave_map. In case no slave can be found the function returns -1. This produces a TLM_ADDRESS_ERROR_RESPONSE and an error message will be written to stdout. In case of success, the transaction is send to the identified slave by calling its b_transport function:</p>
<div class="fragment"><div class="line">ahbOUT[index]-&gt;b_transport(<a class="code" href="fft_8c.html#a261dc6445544ab3a09e5f50b961887b5">trans</a>, delay);</div>
</div><!-- fragment --><p>The LT AHBCTRL adds one cycle of delay to the transaction in order to approximate the delay of the AHB address phase. The delay may be consumed by the slave device or added to the latency of the target. The LT AHBCTRL does not synchronize with the SystemC kernel. The transaction delay is returned to the master, who is responsible for consuming the passed time.</p>
<h2><a class="anchor" id="ahbctrl_p3_3"></a>
AT behaviour</h2>
<p>The AT mode is intended to more accurately approximate the timing of the GRLIB AHBCTRL hardware model. To facilitate architecture exploration features like arbitration and pipelining are taken into account. Therefore, the AT mode of the AHBCTRL is more complex. It e.g. requires multiple parallel SC_THREADs. The operation of the module can be best understood by following the control flow of a transaction.</p>
<p>A new transaction arrives in nb_transport_fw with phase BEGIN_REQ. The function will first create a new connection record. A connection record consists of the master_id (bus id of master), the slave_id (bus id of slave) and a connection state. While the master_id is known, the slave_id still needs to be determined during decode. Hence, at this point in time, slave_id is set to zero. The initial connection state is PENDING. The AHBCTRL keeps track of all transactions using the data structure pending_map. New entries are created by function addPendingTransaction.</p>
<p>In the next step the thread arbitrate_me decides which master will receive the bus in the current cycle. This will be done at intervals of clock_cycle ns. The default clock_cycle time is 10 ns. This setting can be overwritten by connecting a clock to input clk or by one of the set_clk functions of class <a class="el" href="classCLKDevice.html">CLKDevice</a>. Depending on constructor parameter rrobin the transaction with the highest priority (lowest index) or the one pointed by the robin counter is selected. All other transactions have to wait. If there is a winner, the respective transaction is entered in the mRequestPEQ payload event queue. Their transaction state is set to BUSY.</p>
<p>Now the transaction is ready for address decoding. This is done in thread RequestThread. The same mechanisms are used as for LT operation (get_index). The connection record is updated with the index of the slave device. If the transaction is not directed towards the configuration area and a valid slave could be found, it is forwarded to socket ahbOUT:</p>
<div class="fragment"><div class="line">status = ahbOUT[index]-&gt;nb_transport_fw( *<a class="code" href="fft_8c.html#a261dc6445544ab3a09e5f50b961887b5">trans</a>, pase, delay)</div>
</div><!-- fragment --><p>The slave may now respond in multiple different ways. The modules of this library either return TLM_UPDATED with phase END_REQ or TLM_ACCEPTED with phase BEGIN_REQ. In the first case the RequestThread sends END_REQ to the master. In the second it waits for event mEndRequest, which will be triggered as soon nb_transport_bw receives END_REQ from the slave. This completes the address phase of the protocol.</p>
<p>In case of read transaction the slave is expected to continue by sending BEGIN_RESP. If BEGIN_RESP is received by nb_transport_bw, the transaction unblocks the ResponseThread via the mResponsePEQ payload event queue. The ResponseThread uses the pending_map to find back the respective connection record including the index of the master. Afterwards, BEGIN_RESP is send to the master. The master can now copy the data and reply with either TLM_ACCEPTED and BEGIN_RESP, TLM_UPDATE and END_RESP or TLM_COMPLETED. In the first case the thread will wait for END_RESP to be send on the forward path. This is indicated by event mEndResponseEvent. In all other cases the transaction is considered completed and removed from the pending_map.</p>
<p>For more information on the AHB AT implementation please see <a class="el" href="interconnect_methodology.html#interconnect_methodology_ahb">Interconnect Methodology</a>.</p>
<h1><a class="anchor" id="ahbctrl_p4"></a>
Compilation</h1>
<p>For the compilation of the AHBCTRL unit, a WAF wscript file is provided and integrated in the superordinate build mechanism of the library. All required objects for simulating the AHBCTRL on platform level are compiled in a sub-library named ahbctrl using following build command: </p><pre class="fragment">$ ./waf -–target=ahbctrl
</pre><p>To utilize ahbctrl in simulations with other components, add ahbctrl to the use list of your wscript.</p>
<h1><a class="anchor" id="ahbctrl_p5"></a>
Example Instantiation</h1>
<p>The example below demonstrates the instantiation of the AHBCTRL inside a sc_main method or an arbitrary top-level class. The instantiating module needs to include at least ahbctrl.h and amba.h. The AHBCTRL is created in line 19-32. In line 40 the slave port (<code><a class="el" href="classAHBCtrl.html#ab5e9fbf1d4e20ad7b9c1305d7e1fc915" title="AHB slave multi-socket. ">AHBCtrl::ahbIN</a></code>) of the bus is bound to a testbench master. Line 43 shows how to bind a slave to the master socket (<code><a class="el" href="classAHBCtrl.html#a622c97a190d69fffba226a5e8c72f8f1" title="AHB master multi-socket. ">AHBCtrl::ahbOUT</a></code>). Both bus master and slave socket support multiple bindings.</p>
<p>All additional components are to be connected in equal way. How to bind the snoop Signalkit output is shown in line 46. Since the AHBCTRL has some internal storage (config area), it needs a notion of time. In this example the clock cycle time is set in line 49. For the set_clk function multiple prototypes exist. Have a look at class <code><a class="el" href="classCLKDevice.html">CLKDevice</a></code> to learn more.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &quot;tlm.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="common_2amba_8h.html">core/common/amba.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="socrocket_8h.html">core/common/socrocket.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;power_monitor.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="signalkit_8h.html">core/common/signalkit.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;testbench.h&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ahbctrl_8h.html">core/models/ahbctrl/ahbctrl.h</a>&quot;</span></div>
<div class="line"><span class="preprocessor">#include &quot;<a class="code" href="ahbmem_8h.html">core/models/ahbmem/ahbmem.h</a>&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> <a class="code" href="main_8cpp.html#gad82ffd9ab2be145419e6ead48ea59fee">sc_main</a>(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span>** argv) {</div>
<div class="line"></div>
<div class="line">  <span class="comment">// *** CREATE MODULES</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create testbench</span></div>
<div class="line">  testbench tbm(<span class="stringliteral">&quot;Master&quot;</span>, 0x400, 0xfff, 0, sc_core::sc_time(10, SC_NS), amba::amba_LT);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create ahbctrl</span></div>
<div class="line">  <a class="code" href="classAHBCtrl.html">AHBCtrl</a> ahbctrl(<span class="stringliteral">&quot;ahbctrl&quot;</span>,</div>
<div class="line">                   0xfff,         <span class="comment">// ioaddr</span></div>
<div class="line">                   0xfff,         <span class="comment">// iomask</span></div>
<div class="line">                   0xff0,         <span class="comment">// cfgaddr</span></div>
<div class="line">                   0xff0,         <span class="comment">// cfgmask</span></div>
<div class="line">                   0,             <span class="comment">// rrobin (no effect at LT)</span></div>
<div class="line">                   0,             <span class="comment">// split (no effect at Lt)</span></div>
<div class="line">                   0,             <span class="comment">// defmask</span></div>
<div class="line">                   0,             <span class="comment">// ioen</span></div>
<div class="line">                   0,             <span class="comment">// fixbrst</span></div>
<div class="line">                   1,             <span class="comment">// fpnpen</span></div>
<div class="line">                   1,             <span class="comment">// mcheck</span></div>
<div class="line">                   1,             <span class="comment">// pow_mon</span></div>
<div class="line">                   amba::amba_LT);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Create simulation memory</span></div>
<div class="line">  <a class="code" href="classAHBMem.html">AHBMem</a> ahbmem(<span class="stringliteral">&quot;ahbmem&quot;</span>, 0x400, 0xfff, amba::amba_LT, 0);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// *** BIND SOCKETS</span></div>
<div class="line"></div>
<div class="line">  <span class="comment">// Connect testbench master to ahbctrl</span></div>
<div class="line">  tbm.ahb(ahbctrl.<a class="code" href="classAHBCtrl.html#ab5e9fbf1d4e20ad7b9c1305d7e1fc915">ahbIN</a>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Connect ahbctrl to simulation memory</span></div>
<div class="line">  ahbctrl.<a class="code" href="classAHBCtrl.html#a622c97a190d69fffba226a5e8c72f8f1">ahbOUT</a>(ahbmem.<a class="code" href="classAHBSlave.html#a979b8a2794293164649e463b33b2cba5">ahb</a>);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Connect snooping ports</span></div>
<div class="line">  ahbctrl.<a class="code" href="classAHBCtrl.html#a6ca95414d9137fcea01c48877c73bea0">snoop</a>(tbm.snoop);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Set ahbctrl cycle-delay</span></div>
<div class="line">  ahbctrl.<a class="code" href="group__utils.html#ga1e502b9a84a32054d08a28935f19283b">set_clk</a>(10, SC_NS);</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Start of simulation</span></div>
<div class="line">  <span class="comment">// -------------------</span></div>
<div class="line">  sc_core::sc_start();</div>
<div class="line"></div>
<div class="line">  <span class="comment">// Call power analyzer</span></div>
<div class="line">  PM::analyze(<span class="stringliteral">&quot;../../../models/&quot;</span>,<span class="stringliteral">&quot;main-power.dat&quot;</span>,<span class="stringliteral">&quot;ahbctrl.1.lt.power&quot;</span>);</div>
<div class="line"></div>
<div class="line">  <span class="keywordflow">return</span> 0;</div>
<div class="line"></div>
<div class="line">}</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<footer>
  <div class="container">
    <div class="inner">
      <p>
        &nbsp; &copy; 
         <a href="http://www.tu-braunschweig.de/c3e">c3e - TU-Braunschweig</a>. 2012.
        All rights reserved. | <a href="impress.html">Impress</a> |
        Generated on Tue Nov 18 2014 18:54:31 for SoCRocket by &#160;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.7</a>
      </p>
    </div>
  </div>
</footer>
</body>
</html>

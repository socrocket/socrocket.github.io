<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Doxygen 1.8.7">
    <meta name="author" content="meyer@c3e.cs.tu-bs.de">
    <title>SoCRocket: Library base classes</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="bootstrap-theme.min.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="highlight.pack.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen2bootstrap.js"></script>
    <link href="style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body class="mainpage">
    <div class="container">
      <header class="jumbotron masthead">
        <div class="inner">
          <h1>
            <img alt="Logo" src="socrocket-logo.png"/>
            SoCRocket
          </h1>
          <p>Transaction-Level Modeling Framework for Space Applications</p>
        </div>
      </header>
    </div>
  <div class="container" id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Library base classes </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>verify and beautify his document</dd></dl>
<p>Clock Device:</p>
<p>class <a class="el" href="classCLKDevice.html">CLKDevice</a> models/utils/clkdevice.* lib utils</p>
<p>The class <a class="el" href="classCLKDevice.html">CLKDevice</a> is used to consistently distribute clock/timing and reset amongst all IPs of the library. Devices that inherit from <a class="el" href="classCLKDevice.html">CLKDevice</a> receive two SignalKit inputs: clk and rst. If the child requires reset behavior, it may implement the virtual function dorst(), which is triggered by the rst input. Moreover, <a class="el" href="classCLKDevice.html">CLKDevice</a> provides a data member „clock_cycle“, which can be used by the child to determine the clock period for delay calculations. The value of clock_cycle is set by connecting a sc_time SignalKit signal to the clk input or by calling one of the various set_clk functions of the class.</p>
<p>AHB Device:</p>
<p>class <a class="el" href="classAHBDevice.html">AHBDevice</a> models/utils/ahbdevice.* lib utils</p>
<p>All simulation models that are supposed to be connected to the TLM AHBCTRL must be derived from the class <a class="el" href="classAHBDevice.html">AHBDevice</a>. Usually, this is indirectly done by inheriting from the AHB Master or AHB Slave classes (see below). The Aeroflex Gaisler AHBCTRL implements a Plug &amp; Play mechanism, which relies on configuration information that is collected from the attached masters and slaves. <a class="el" href="classAHBDevice.html">AHBDevice</a> models the respective configuration data records. The structure of these records is described in RD04. At start_of_simulation the TLM AHBCTRL iterates through all connected modules to retrieve AHB bar &amp; mask and build up its internal routing table.</p>
<p>AHB Master: class <a class="el" href="classAHBMaster.html">AHBMaster</a> models/utils/ahbmaster.* lib utils</p>
<p>Almost all models implementing an AHB master interface (except busses) are derived from class <a class="el" href="classAHBMaster.html">AHBMaster</a>. <a class="el" href="classAHBMaster.html">AHBMaster</a> is a convenience class providing an AHB master socket and implementations of various access functions for reading/writing data over the bus. <a class="el" href="classAHBMaster.html">AHBMaster</a> inherits <a class="el" href="classAHBDevice.html">AHBDevice</a> and can be configured for loosely timed (LT) or approximately timed (AT) level of abstraction.</p>
<p>An overview about how to build own components based on <a class="el" href="classAHBMaster.html">AHBMaster</a> is given in 3.7. AHB Slave: class <a class="el" href="classAHBSlave.html">AHBSlave</a> models/utils/ahbslave.*</p>
<p>Almost all models implementing an AHB slave interface (except busses) are derived from class <a class="el" href="classAHBSlave.html">AHBSlave</a>. <a class="el" href="classAHBSlave.html">AHBSlave</a> is a convenience class providing an AHB slave socket and callback functions for hooking up with the behaviour of user models. <a class="el" href="classAHBSlave.html">AHBSlave</a> inherits <a class="el" href="classAHBDevice.html">AHBDevice</a> and can be configured for loosely timed (LT) or approximately timed (AT) level of abstraction.</p>
<p>An overview about how to build own components based on <a class="el" href="classAHBSlave.html">AHBSlave</a> is given in 3.7.</p>
<p>APB Device:</p>
<p>class <a class="el" href="classAPBDevice.html">APBDevice</a> models/utils/apbdevice.* lib utils</p>
<p>All simulation models that are supposed to be connected to the TLM APBCTRL must be derived from class <a class="el" href="classAPBDevice.html">APBDevice</a>. Similar to the concept of <a class="el" href="classAHBDevice.html">AHBDevice</a>, the child inherits Plug &amp; Play configuration records representing its device type and address. At start_of_simulation the APBCTRL iterates through the connected slaves collecting all APB bar and mask settings for building up its routing table. Modules, like the MCTRL, which posses an AHB as well as an APB interface must be derived from <a class="el" href="classAHBDevice.html">AHBDevice</a> and <a class="el" href="classAPBDevice.html">APBDevice</a>.</p>
<p><a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> Device:</p>
<p>class <a class="el" href="classMEMDevice.html">MEMDevice</a> models/utils/memdevice.* lib utils</p>
<p>The class <a class="el" href="classMEMDevice.html">MEMDevice</a> is the base class of all memories to be connected to the MCTRL. The library provides a Generic <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a>, which implements the given interface. The included functions are required to determine the features of the attached component for correct access and delay calculation.</p>
<p>Timing Monitor:</p>
<p>class timingmonitor common/timingmonitor.* lib common</p>
<p>Timingmonitor is a support class for timing verification. Within the library it is used in almost all testbench classes. During simulation it records the SystemC simulation time and the real execution time of test phases. For this purpose it provides a set of static control functions. A test phase starts with a call to phase_start_timing. The function expects a phase ID and a phase description as inputs. This will create a new entry in the internal timing map. After completion of the test phase, the testbench calls phase_end_timing to close the record. At the end of the test, the testbench may now call report_timing to generate a report showing the timing of all test phases. This is especially useful for comparing simulations at different levels of abstraction.</p>
<p>Verbosity:</p>
<p>class color, number, msgstream common/verbose.*</p>
<p>The operators defined in verbose.h can be used to filter output messages respecting their severity. As explained in 2.2.2 the verbosity level of the simulations must be defined during configuration of the library (./waf configure –verbosity=1..5). Five levels may be chosen: error, warning, report, info and debug. The operators are used in a similar way to C++ stdout:</p>
<p>std::cout &lt;&lt; value &lt;&lt; std::endl; // Regular C++ stdout</p>
<p><a class="el" href="namespacev.html#a8175de451203b69dd990b52c97994ef1">v::error</a> &lt;&lt; value &lt;&lt; v::endl; // Verbosity error stream <a class="el" href="namespacev.html#a6f67163d47f17185ed247d4ba03f341b">v::warn</a> &lt;&lt; value &lt;&lt; v::endl; // Verbosity warn stream <a class="el" href="namespacev.html#aeab8e77e452286bbc0eb67027430efe7">v::report</a> &lt;&lt; value &lt;&lt; v::endl; // Verbosity report stream <a class="el" href="namespacev.html#a893c60ee5398ed06026abe24e4786a19">v::info</a> &lt;&lt; value &lt;&lt; v::endl; // Verbosity info stream <a class="el" href="namespacev.html#af32429aace6d7865e49ec226dfb811f9">v::debug</a> &lt;&lt; value &lt;&lt; v::endl; // Verbosity debug stream Defining the verbosity at configuration time has the advantage that undesired output is optimized way (compared to runtime switching).</p>
<p>Endianess:</p>
<p>class none common/vendian.h lib common</p>
<p>The header vendian.h provides endianess conversion functions for data types of different lengths. If the host system is little endian, CPU and unit tests must swap byte order. The latter is defined by the macro LITTLE_ENDIAN_BO. It has to be kept in mind that the LEON processor is a big endian CPU. Hence, memory images generated with the SPARC compiler (e.g. BCC) are also big endian. If the host system simulates the CPU, or testbench, in little endian byte order, all data items going to/from memory must be reordered!</p>
<p>VMAP: class none common/vmap.h lib common</p>
<p>To save system memory and optimize simulation performance large, sparse memories should be implemented as maps. In this case the memory address represents the key and the actual data the entry. Because the performance of the various existing map implementation strongly depends on the system environment, the SoCRocket library provides the flexible type vmap. The vmap.h header contains a macro defining vmap as either std::map, hash_map or std::tr1::unordered_map. An example for the usage of vmap is given by the MapMemory implementation of the Generic <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> (7). </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<footer>
  <div class="container">
    <div class="inner">
      <p>
        &nbsp; &copy; 
         <a href="http://www.tu-braunschweig.de/c3e">c3e - TU-Braunschweig</a>. 2012.
        All rights reserved. | <a href="impress.html">Impress</a> |
        Generated on Tue Nov 18 2014 18:54:30 for SoCRocket by &#160;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.7</a>
      </p>
    </div>
  </div>
</footer>
</body>
</html>

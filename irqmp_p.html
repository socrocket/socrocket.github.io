<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Doxygen 1.8.6">
    <meta name="author" content="meyer@c3e.cs.tu-bs.de">
    <title>SoCRocket: Irqmp - Interrupt Controler for multiple Processors</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="style-doxygen.css" rel="stylesheet" type="text/css" />
    <link href="bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="bootstrap-theme.min.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="highlight.pack.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen2bootstrap.js"></script>
    <link href="style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body class="mainpage">
    <div class="container">
      <header class="jumbotron masthead">
        <div class="inner">
          <h1>
            <img alt="Logo" src="socrocket-logo.png"/>
            SoCRocket
          </h1>
          <p>Transaction-Level Modeling Framework for Space Applications</p>
        </div>
      </header>
    </div>
  <div class="container" id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="usermanual.html">User Manual</a></li><li class="navelem"><a class="el" href="models_p.html">IP Models</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classIrqmp.html">Irqmp</a> - Interrupt Controler for multiple Processors </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#irqmp_p1">Functionality and Features</a><ul><li class="level2"><a href="#irqmp_p1_1">Overview</a></li>
<li class="level2"><a href="#irqmp_p1_2">Control Registers</a></li>
<li class="level2"><a href="#irqmp_p1_3">Interrupt Prioritization and Forwarding</a></li>
<li class="level2"><a href="#irqmp_p1_4">Extended Interrupt Handling</a></li>
<li class="level2"><a href="#irqmp_p1_5">Processor Status Monitoring</a></li>
<li class="level2"><a href="#irqmp_p1_6">Power Modeling</a></li>
</ul>
</li>
<li class="level1"><a href="#irqmp_p2">Interface</a></li>
<li class="level1"><a href="#irqmp_3">Internal Structure</a><ul><li class="level2"><a href="#irqmp_p3_1">The irqmp.h file</a></li>
<li class="level2"><a href="#irqmp_p3_2">The irqmp.cpp file</a></li>
</ul>
</li>
<li class="level1"><a href="#irqmp_p4">Compilation</a></li>
<li class="level1"><a href="#irqmp_p5">Example Instantiation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="irqmp_p1"></a>
Functionality and Features</h1>
<h2><a class="anchor" id="irqmp_p1_1"></a>
Overview</h2>
<p>The SystemC IRQMP unit models behaviour and timing of the IRQMP VHDL model from the Aeroflex/Gaisler GRLIB (<a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a>). Purpose of the IP is the priorization and masking of the interrupts from all AHB and APB devices in the system. The interrupt with the highest priority is propagated to one or multiple processors. Up to 16 LEON3 cores are supported. Two different modes of IR distribution are implemented:</p>
<ul>
<li>The IR is forwarded to all cores and cleared by the first core that acknowledges the IR (i.e. the ISR is processed only once).</li>
<li>The IR is broadcasted and has to be acknowledged (and processed) by each of the cores.</li>
</ul>
<p>Interrupts can be masked for each core separately. The data path or the IRQMP unit is not pipelined, i.e. all operations can be performed within one clock cycle.</p>
<p>The GRLIB interrupt scheme comprises a 32-bit interrupt (IR) bus, which is routed in parallel to the AMBA bus signals. The 16 LSBs of the IR bus are associated to regular IRs and the 16 MSBs to extended IRs (EIR). In the SoCRocket library IRs are modeled using the TLM SignalKit. Interrupts from any simulation model can be bound to the IRQMP using the connect method.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>is this still correct?</dd></dl>
<p>The following command connects the <a class="el" href="classGPTimer.html" title="This class is a TLM 2.0 Model of the Aeroflex Gaisler GRLIB GPTimer. Further informations to the orig...">GPTimer</a> interrupt output number 3 (<code>SignalKit::selector</code>) with the IRQMP interrupt input number 5.: </p>
<div class="fragment"><div class="line"><a class="code" href="namespacesr__signal.html#a1abd745bc2565a6e3a662ad1083bc1b8">connect</a>(<a class="code" href="structgptimer.html">gptimer</a>.irq, irqmp.<a class="code" href="classIrqmp.html#a9bfe1b1e93a84b174411ea6f11a53fe0">irq_in</a>, 3, 5);</div>
</div><!-- fragment --><p>In case the sending device has only one interrupt output (<code>SignalKit::out</code>) only one channel number (for the IRQMP) must be defined: </p>
<div class="fragment"><div class="line"><a class="code" href="namespacesr__signal.html#a1abd745bc2565a6e3a662ad1083bc1b8">connect</a>(socwire.irq, irqmp.<a class="code" href="classIrqmp.html#a9bfe1b1e93a84b174411ea6f11a53fe0">irq_in</a>, 6);</div>
</div><!-- fragment --><p>The connection of the IRQMP towards the processors is implemented in very similar way.</p>
<h2><a class="anchor" id="irqmp_p1_2"></a>
Control Registers</h2>
<p>The IRQMP can be configured and controlled by a set of memory-mapped registers (Table 32). All control registers are 32 bit wide and implemented in form of a register bank. Therefore, as described in 3.4, class <code><a class="el" href="classIrqmp.html">Irqmp</a></code> is a child of class <code><a class="el" href="classAPBSlave.html">APBSlave</a></code>. An overview about the available registers is given in Table 32.</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 32 – IRQMP Registers</caption>
<tr id="HeadRow">
<th id="FirstColumn">APB Address Offset</th><th id="LastColumn">Register </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">0x00</td><td id="LastColumn">Interrupt Level Register </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">0x04</td><td id="LastColumn">Interrupt Pending Register </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">0x08</td><td id="LastColumn">Interrupt Force Register (NCPU = 0) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">0x0C</td><td id="LastColumn">Interrupt Clear Register </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">0x10</td><td id="LastColumn">Multiprocessor Status Register </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">0c14</td><td id="LastColumn">Broadcast Register </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">0x40 + 4 * n</td><td id="LastColumn">Processor n Interrupt Mask Register </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">0x80 + 4 * n</td><td id="LastColumn">Processor n Interrupt Force Register </td></tr>
<tr id="LastRow">
<td id="FirstColumn">0xC0 + 4 * n</td><td id="LastColumn">Processor n Extended Interrupt Identification Register </td></tr>
</table>
<p>All registers can be written to configure or operate the IRQMP unit. Only the Extended Interrupt Identification Register is read-only. The function and configuration options of the registers are described in full detail in section 66 of <a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a>. However, two differences between <a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a> and the SystemC implementation have to be noted:</p>
<ol type="1">
<li>The Interrupt Force Register for NCPU = 0 has been left out in the SystemC implementation. In a single-processor system the function of the Interrupt Force Register is identical to that of the Interrupt Pending Register.</li>
<li>In <a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a> it is stated that the bits [31..17] of the Interrupt Clear Register are all constantly pulled down to ‘0’. This differs from the VHDL implementation, in which these bits are used for extended interrupt clearance. Respectively, an EIR can also be cleared by software. The SystemC implementation follows the VHDL implementation rather than the manual.</li>
</ol>
<h2><a class="anchor" id="irqmp_p1_3"></a>
Interrupt Prioritization and Forwarding</h2>
<p>The IRs are prioritized in a two-dimensional prioritization scheme. Both dimensions are referred to as “interrupt level” in <a href="http://gaisler.com/products/grlib/grip.pdf">GRLIB IP Core User’s Manual</a>. For clarification purposes, terms will be redefined in this document.</p>
<p>The Interrupt Level Register determines the first dimension of prioritization. For each IR line, the according bit in the IR Level Register can be set to level 0 or level 1. Each level 1 IR has got a higher priority than any level 0 IR. The first dimension of prioritization will be referred to as “interrupt level” throughout this document.</p>
<p>The 16 regular IR lines are modeled with a 16-bit vector. The most significant bit (IR15) has got the highest priority and IR1 has got the lowest priority. IR0 is reserved. This second dimension of prioritization will be referred to as “interrupt line” throughout this document.</p>
<p>When several IRs are pending, the highest priority IR will be calculated according to the scheme described above. Which core receives the interrupt request (IRQ) depends on the settings in the Broadcast Register and the Interrupt Mask Registers of the individual cores. As shown in Figure 6, the use of the IR Pending or IR Force Registers is determined by the Broadcast Register.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>add figure here from word file</dd></dl>
<p>Figure 6 – Interrupt Distribution Scheme</p>
<p>The Interrupt Broadcast Register can be set for each IR line individually. If the broadcast bit of an interrupt line is set, the IRQ is sent to all cores and also has to be acknowledged (i.e. the ISR has to be processed) all of them. This is accomplished by setting the Interrupt Force Registers of all the cores. Each core has to individually clear its Interrupt Force Register!</p>
<p>If the broadcast bit is not set, the IRQ is sent to all cores and has to be acknowledged only once, i.e. only the first core that acknowledges the IR has to process the ISR. This is done by setting the Interrupt Pending Register, which can be cleared by any of the cores. In uni-processor systems the Broadcast Register is disabled.</p>
<p>Interrupts can be masked for each core individually. If bit n of the Interrupt Mask Register of core m is set to 0, then interrupt n is masked for this core, i.e. core m will never receive IRQ n. As a matter of fact, the VHDL implementation does not prevent an interrupt n clearance by core m in this case. For now, the SystemC module has been aligned to this behavior.</p>
<p>Interrupt masking takes place before prioritization, so the highest priority unmasked IR is always forwarded to the processors.</p>
<p>Interrupt 15 cannot be masked by the LEON3 core and should be used with care. Most operating systems do not safely handle this IR.</p>
<h2><a class="anchor" id="irqmp_p1_4"></a>
Extended Interrupt Handling</h2>
<p>In the IRQMP extended interrupts are cascaded, i.e. one of the regular IR lines may be defined as a cascade for the 16 EIR lines. The cascade is defined in bits 19..16 of the Multiprocessor Status Register.</p>
<p>If EIRs are asserted and the cascade is the highest priority active regular IR, the cascade is forwarded to the cores. After receiving the interrupt acknowledge signal from a core, the IRQMP unit writes the number of the asserted EIR line into the Extended Interrupt Identification Register. Thus, the ISR of the cascade has to send the acknowledge signal and afterwards read the EIR ID Register to call the correct ISR of the asserted EIR.</p>
<h2><a class="anchor" id="irqmp_p1_5"></a>
Processor Status Monitoring</h2>
<p>The processor status can be monitored through the Multiprocessor Status Register. The STATUS field [15..0] in this register indicates whether a processor is halted (<code>1</code>) or running (<code>0</code>). A halted processor can be reset and restarted by writing a <code>1</code> to its STATUS field.</p>
<p>After reset, all processors except processor 0 are on halt. Once the system is properly initialized, processor 0 may start all other processors by switching on the respective STATUS bits.</p>
<p>To support this mechanism the LEON ISS, which is shipped with this library, has been modified. It provides a SignalKit input run and a SignalKit output status. Both signals are of type bool and must be routed to the <code>cpu_rst</code> and <code>cpu_stat</code> ports of the <code><a class="el" href="classIrqmp.html">Irqmp</a></code>. The Multiprocessor Status Register is kept in sync with the status information provided by the various processors.</p>
<h2><a class="anchor" id="irqmp_p1_6"></a>
Power Modeling</h2>
<p>Power monitoring can be enabled by setting the constructor parameter <code>pow_mon</code> to <code>true</code>. The model is annotated with default power information that has been gathered using a generic 90nm Standard-Cell Library and statistical power estimation at Gate-Level.</p>
<p>The accuracy of the build-in power models and the default switching energy settings cannot be guaranteed. In order to achieve the best possible results the user is recommended to annotate the design with custom target-technology dependent power information.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000018">Todo:</a></b></dt><dd>verify this section and find out about the power modeling report</dd></dl>
<p>The power model of the <code><a class="el" href="classIrqmp.html">Irqmp</a></code>, all required parameters, and default settings are explained in the SoCRocket Power Modeling Report [RD11].</p>
<h1><a class="anchor" id="irqmp_p2"></a>
Interface</h1>
<p>The GRLIB VHDL model of the IRQMP is configured using Generics. For the implementation of the TLM model most of these Generics were refactored to constructor parameters of class <a class="el" href="classIrqmp.html">Irqmp</a>. An overview about the available parameters is given in Table 33.</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 33 - Template Parameters</caption>
<tr id="HeadRow">
<th id="FirstColumn">Parameter</th><th id="MiddleColumn">Function</th><th id="MiddleColumn">Allowed Range</th><th id="LastColumn">Default </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">name</td><td id="MiddleColumn">SystemC name of the module</td><td id="MiddleColumn"></td><td id="LastColumn"></td></tr>
<tr id="BodyRow">
<td id="FirstColumn">pindex</td><td id="MiddleColumn">Selects which APB select signal (PSEL) will be used to access the IRQMP unit</td><td id="MiddleColumn">0 to NAPBMAX– 1</td><td id="LastColumn">0 </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">paddr</td><td id="MiddleColumn">The 12-bit MSB APB address</td><td id="MiddleColumn">0 to 4095</td><td id="LastColumn">0 </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">pmask</td><td id="MiddleColumn">The APB address mask</td><td id="MiddleColumn">0 to 4095</td><td id="LastColumn">4095 </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ncpu</td><td id="MiddleColumn">Number of processors in multicore systems</td><td id="MiddleColumn">1 to 16</td><td id="LastColumn">1 </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">eirq</td><td id="MiddleColumn">The cascade line of EIRs</td><td id="MiddleColumn">0 to 15</td><td id="LastColumn">0 </td></tr>
<tr id="LastRow">
<td id="FirstColumn">pow_mon</td><td id="MiddleColumn">Enable power monitoring</td><td id="MiddleColumn">0 to 1</td><td id="LastColumn">0 </td></tr>
</table>
<p>The system-level interface of the module comprises an GreenSocs/Carbon APB slave socket and multiple SoCRocket SignalKit ports (Table 34).</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 34 - IRQMP SignalKit sockets</caption>
<tr id="HeadRow">
<th id="FirstColumn">Name</th><th id="MiddleColumn">Type</th><th id="MiddleColumn">In/Out</th><th id="LastColumn">Description </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">rst</td><td id="MiddleColumn">bool</td><td id="MiddleColumn">in</td><td id="LastColumn">Reset prescaler and all counters </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">clk</td><td id="MiddleColumn">sc_time</td><td id="MiddleColumn">in</td><td id="LastColumn">Annotates clock period </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">cpu_rst</td><td id="MiddleColumn">bool</td><td id="MiddleColumn">selector</td><td id="LastColumn">Generate reset for the processor(s) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">cpu_stat</td><td id="MiddleColumn">bool</td><td id="MiddleColumn">infield</td><td id="LastColumn">Receive status inf. (halt/running) from processor(s) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">irq_req</td><td id="MiddleColumn">uint32_t</td><td id="MiddleColumn">selector</td><td id="LastColumn">Interrupt requests for the processors(s) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">irq_ack</td><td id="MiddleColumn">uint32_t</td><td id="MiddleColumn">infield</td><td id="LastColumn">Interrupt ackknowledge signals from processors(s) </td></tr>
<tr id="LastRow">
<td id="FirstColumn">irq_in</td><td id="MiddleColumn">uint32_t</td><td id="MiddleColumn">infield</td><td id="LastColumn">Muxed interrupts from IRQ sources </td></tr>
</table>
<h1><a class="anchor" id="irqmp_3"></a>
Internal Structure</h1>
<p>This section describes the internal structure of the <code><a class="el" href="classIrqmp.html">Irqmp</a></code>. The class hierarchy of the model is flat. All functionality is comprised in class <code>Irpmp</code>, which is described in the files irqmp.h and <a class="el" href="irqmp_8cpp.html">irqmp.cpp</a>.</p>
<h2><a class="anchor" id="irqmp_p3_1"></a>
The irqmp.h file</h2>
<p>The IRQMP unit consists of only one class. The irqmp.h file contains the module class definition. The parameterization options, implemented as generics in the VHDL model, are realized as constructor parameters of the class.</p>
<p>Class <code><a class="el" href="classIrqmp.html">Irqmp</a></code> is a child of <a class="el" href="classAPBSlave.html">APBSlave</a>. A <a class="el" href="classAPBSlave.html">APBSlave</a> is an encapsulation for a complete functional unit and provides containment structures for other elements, e.g. registers. Moreover, <code><a class="el" href="classIrqmp.html">Irqmp</a></code> inherits the PNP configuration record of class <a class="el" href="classAPBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">APBDevice</a>, and the clock and reset interface defined in <code><a class="el" href="classCLKDevice.html">CLKDevice</a></code>. The <a class="el" href="classIrqmp.html">Irqmp</a> class definition contains the module interface and the function prototypes of constructor, destructor, and callback functions. Next, to the well-known <code>SC_HAS_PROCESS</code> macro, the model call <code>SK_HAS_SIGNALS</code> for registration with the SignalKit.</p>
<h2><a class="anchor" id="irqmp_p3_2"></a>
The irqmp.cpp file</h2>
<p>The constructor of <code><a class="el" href="classIrqmp.html">Irqmp</a></code> configures the <code><a class="el" href="classAPBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">APBDevice</a></code>, the <code>gr_device</code> and the bus interface. It constructs a register bank <code>r</code>, in which it implements all the registers listed in Table 32. The register bank is a C++ class implemented in the sc register libraries that provides memory management and interface functions. Within this register bank, a register may be instantiated like in the following code snippet:</p>
<div class="fragment"><div class="line">r.create_register(<span class="stringliteral">&quot;pending&quot;</span>, <span class="stringliteral">&quot;Interrupt Pending Register&quot;</span>,</div>
<div class="line">                  0x04,</div>
<div class="line">                  0x00000000,</div>
<div class="line">                  IRQMP_IR_PENDING_EIP | IRQMP_IR_PENDING_IP,</div>
<div class="line">            );</div>
</div><!-- fragment --><p>The arguments to the <code>create_register()</code> function are name, description, offset, init value, write mask. For a detailed description of these options, please refer to the <code>r_register</code> documentation.</p>
<p>In addition to building the interface, the constructor registers the <code>SC_THREAD</code> <code><a class="el" href="group__irqmp.html#ga322584119497ffe5e5e5cf86cadbffb7">Irqmp::launch_irq</a></code>. The <code><a class="el" href="group__irqmp.html#ga322584119497ffe5e5e5cf86cadbffb7">Irqmp::launch_irq</a></code> thread is sensitive to the SystemC event <code>e_signals</code> and contains the behavioral core of the model. The <code>e_signals</code> event is triggered from three locations:</p>
<ul>
<li>incoming_irq: Handler bound to irq_in socket, receiving the interrupts from all interrupt sources in the system.</li>
<li>ackknowledge_irq: Handler bound to irq_ack socket, receiving the ackknowledge signals from the processors.</li>
<li>clear_write: Callback bound to Interrupt Clear register</li>
<li>force_write: Callback bound to Interrupt Force register</li>
<li>pending_write: Callback bound to Interrupt Pending register</li>
</ul>
<p>For every state change in one of the observed registers or sockets, the launch_irq function recalculates the IR lines for all connected processors. This is done in a loop starting from the processor with the highest ID. For each processor <code>launch_irq</code> combines the pending register with the processor interrupt mask, to check whether there is an IR pending. It also checks for extended and forced IRs. From the resulting mask of IRs, the thread selects the level 1 IR with the highest priority for submission. Level 0 IRs are only considered, if there is no level 1 IR waiting. The selected IR is written to the processor as follows: </p>
<div class="fragment"><div class="line">irq_req.write(1 &lt;&lt; cpu, std::pair&lt;uint32_t, bool&gt;(number, <span class="keyword">true</span>));</div>
</div><!-- fragment --><p>The first argument of the expression selects the processor, the second is a <code>std::pair</code> consisting of the interrupt number and a <code>boolean</code> value. The latter defines whether the interrupt line is switched on or off. This feature is especially important for RTL co-simulation. For plain TLM simulation transmission of the IR number would be sufficient.</p>
<h1><a class="anchor" id="irqmp_p4"></a>
Compilation</h1>
<p>For the compilation of the IRQMP unit, a WAF wscript file is provided and integrated in the superordinate build mechanism of the library. All required objects for simulating the IRQMP are compiled in a sub-library named irqmp using following command: </p>
<pre class="fragment">$ ./waf –target=irqmp
</pre><p>To utilize the IRQMP in simulations with other components, add irqmp to the use list of your wscript.</p>
<h1><a class="anchor" id="irqmp_p5"></a>
Example Instantiation</h1>
<p>The example below demonstrates the instantiation of the IRQMP TL model is a sc_main or an arbitraty top-level class. The module is created in line 12. Line 15 connects the APB slave socket to the testbench (or APBCTRL). Lines 18 – 21 show how to bind the SignalKit sockets directed to the processor side. The Interrupt sources (irq_in) are connected in line 26. The timing is annotated in line 30.</p>
<div class="fragment"><div class="line"><span class="comment">// Define Testbench</span></div>
<div class="line">Testbench testbench;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Define IRQMP</span></div>
<div class="line"><a class="code" href="classIrqmp.html">Irqmp</a> irqmp;</div>
<div class="line"></div>
<div class="line"><span class="comment">// Constructor</span></div>
<div class="line"><a class="code" href="classTop.html">Top</a>(<a class="code" href="group__common.html#ga93334c42d2c8963eba8961af0921a75a">ModuleName</a> mn) : sc_module(mn),</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Create Testbench &amp; IRQMP</span></div>
<div class="line">        testbench(<span class="stringliteral">&quot;testbench&quot;</span>, <a class="code" href="mptest_8c.html#a656a1de97161c2fe5a415cdc142b3ab3">pindex</a>, paddr, pmask, ncpu, eirq),</div>
<div class="line">        irqmp(<span class="stringliteral">&quot;irqmp&quot;</span>, paddr, pmask, ncpu, eirq, 0) {</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Bind IRQMP APB socket to testbench</span></div>
<div class="line">        testbench.apb_mst(irqmp.apb_slv);</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Connect multiple virtual CPUs (testbenches) to IRQMP</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>=0; <a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>&lt;ncpu; ++<a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>) {</div>
<div class="line">            <a class="code" href="namespacesr__signal.html#a1abd745bc2565a6e3a662ad1083bc1b8">connect</a>(testbench.cpu_rst, irqmp.<a class="code" href="classIrqmp.html#a4be514e84207b5798a5b2dfb799c51f7">cpu_rst</a>, <a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>);</div>
<div class="line">            <a class="code" href="namespacesr__signal.html#a1abd745bc2565a6e3a662ad1083bc1b8">connect</a>(testbench.irq_req, irqmp.<a class="code" href="classIrqmp.html#a7eb80ce8f1c6076e25538fab8b86c086">irq_req</a>, <a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>);</div>
<div class="line">            <a class="code" href="namespacesr__signal.html#a1abd745bc2565a6e3a662ad1083bc1b8">connect</a>(testbench.irq_ack, irqmp.<a class="code" href="classIrqmp.html#a304a0113bbdb4f947141cc9d15d33cb0">irq_ack</a>, <a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Connect multiple interrupt sources to IRQMP</span></div>
<div class="line">        <span class="keywordflow">for</span>(<span class="keywordtype">int</span> <a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>=0; <a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>&lt;32; ++<a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>) {</div>
<div class="line">            <a class="code" href="namespacesr__signal.html#a1abd745bc2565a6e3a662ad1083bc1b8">connect</a>(testbench.irq_out, irqmp.<a class="code" href="classIrqmp.html#a9bfe1b1e93a84b174411ea6f11a53fe0">irq_in</a>, <a class="code" href="mp-hello_8c.html#adbcc01e8bbdb710795e025b5bc543c0b">i</a>);</div>
<div class="line">        }</div>
<div class="line"></div>
<div class="line">        <span class="comment">// Annotate timing</span></div>
<div class="line">        irqmp.<a class="code" href="group__utils.html#ga1e502b9a84a32054d08a28935f19283b">set_clk</a>(10.0, SC_NS);</div>
</div><!-- fragment --> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<footer>
  <div class="container">
    <div class="inner">
      <p>
        &nbsp; &copy; 
         <a href="http://www.tu-braunschweig.de/c3e">c3e - TU-Braunschweig</a>. 2015.
        All rights reserved. | <a href="impress.html">Impress</a> |
        Generated on Tue Nov 24 2015 15:08:59 for SoCRocket by &#160;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.6</a>
      </p>
    </div>
  </div>
</footer>
</body>
</html>

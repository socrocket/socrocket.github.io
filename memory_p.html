<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Doxygen 1.8.7">
    <meta name="author" content="meyer@c3e.cs.tu-bs.de">
    <title>SoCRocket: Memory Models</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="doxygen.css" rel="stylesheet" type="text/css" />
    <link href="bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="bootstrap-theme.min.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="highlight.pack.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen2bootstrap.js"></script>
    <link href="style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body class="mainpage">
    <div class="container">
      <header class="jumbotron masthead">
        <div class="inner">
          <h1>
            <img alt="Logo" src="socrocket-logo.png"/>
            SoCRocket
          </h1>
          <p>Transaction-Level Modeling Framework for Space Applications</p>
        </div>
      </header>
    </div>
  <div class="container" id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="usermanual.html">User Manual</a></li><li class="navelem"><a class="el" href="models_p.html">IP Models</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title"><a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> Models </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h2>Functionality and Features</h2>
<h3>Overview</h3>
<p>The Generic <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> (GM) model is not based on any reference design from the Gaisler GRLIB. It was developed from scratch to complement the SoCRocket MCTRL unit. The GM comes in two implementation flavors: Map and array memory. Both provide exactly the same functionality and interfaces, only the internal data representation differs. The map memory uses a vmap, which can be either a std::map, a hash map or a tr1 hash map. The array memory stores its data in a flat array. It is recommended to use the map memory for large sparse memories. For small memories the array implementation yields better performance. The GM is generic in a sense that it can act as one of four supported memory types: PROM, IO, SRAM or SDRAM. All memories to be connected to the MCTRL must be derived from class MemDevice, which encapsulates all configuration options. The MCTRL uses this interface to determine the features of the attached components. The GM models default devices, which means its behaviour is plain functional. All timing related features are provided and controlled by the MCTRL. As any memory controller needs to know all the timing information of the attached memory device anyway, the delay can be added in the memory controller to keep the memory itself universally applicable. Respectively, the GM is merely used to store data and to identify the device on system level.</p>
<h3>Power Modeling</h3>
<p>Power monitoring can be enabled by setting the constructor parameter pow_mon to true. The model is annotated with default power information that has been gathered using a generic 90nm Standard-Cell Library and statistical power estimation at Gate-Level. The accuracy of the build-in power models and the default switching energy settings cannot be guaranteed. In order to achieve the best possible results the user is recommended to annotate the design with custom target-technology dependent power information. The power model of the Generic <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a>, all required parameters, and default settings are explained in the SoCRocket Power Modeling Report [RD11].</p>
<h2>Interface</h2>
<p>Both implementations of the Generic <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> can be configured using the same set of constructor parameters.</p>
<table class="doxtable">
<tr>
<th>Parameter </th><th>Description  </th></tr>
<tr>
<td>name </td><td>SystemC name of the module </td></tr>
<tr>
<td>type </td><td><a class="el" href="group__utils.html#ga86be4ba2577f97972188c7a541e3aead" title="Device type. ">MEMDevice::device_type</a> (0 – ROM, 1 - IO, 2 – SRAM, 3 – SDRAM) </td></tr>
<tr>
<td>banks </td><td>Number of parallel banks to be modeled </td></tr>
<tr>
<td>bsize </td><td>Size of one memory bank (All banks always considered to have equal size) </td></tr>
<tr>
<td>bits </td><td>Bit width of memory </td></tr>
<tr>
<td>cols </td><td>Number of SDRAM cols </td></tr>
<tr>
<td>implementation </td><td><a class="el" href="group__memory.html#gga314f40764559b624bad6b93d573ef8dba2b51bd79816f99378b5abcf7718bb849">BaseMemory::MAP</a> or <a class="el" href="group__memory.html#gga314f40764559b624bad6b93d573ef8dba321d350ceab4c2d49e3fe3b2668077d1">BaseMemory::ARRAY</a> </td></tr>
<tr>
<td>pow_mon </td><td>Enable power monitoring </td></tr>
</table>
<p>Generic <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> Constructor Parameters</p>
<p>The system-level interface consists of a TLM 2.0 target socket (GreenSocket). The TLM payload comprises an extension for clearing memory regions (<a class="el" href="structext__erase.html">ext_erase</a>). In the current version of the model this feature is only used by the SDRAM controller. Since the GM is a plain functional model the communication with the MCTRL is based on blocking transport (LT).</p>
<h2>Internal Structure</h2>
<p>This section describes the internal structure of both Generic Memories. All TLM functionality is comprised in class <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a>. The power estimation functionality is described in <a class="el" href="classMemoryPower.html">MemoryPower</a>, whereas the base functionality is described in <a class="el" href="classBaseMemory.html">BaseMemory</a>. The storage implementation is in <a class="el" href="classMapStorage.html">MapStorage</a> or <a class="el" href="classArrayStorage.html">ArrayStorage</a> and is instatiated according to the constructor parameter in <a class="el" href="classBaseMemory.html">BaseMemory</a>. File ext_erase.h provides an additional payload extension, which is used by both implementations to organize the clearing of memory regions in SDRAM mode.</p>
<h3>Interface MemDevice</h3>
<p>The Generic <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a> implements the interface <a class="el" href="classMEMDevice.html">MEMDevice</a>. The <a class="el" href="classMEMDevice.html">MEMDevice</a> interface enables the MCTRL to identify the type of the memory (PROM, IO, SRAM, SDRAM) and its main configuration parameters. For access to this parameters every <a class="el" href="classMEMDevice.html">MEMDevice</a> provides a set of virtual functions, which can be overwritten by the child class. The GM uses the default implementation of the access functions. get_type – Returns the memory type (<a class="el" href="group__utils.html#ga86be4ba2577f97972188c7a541e3aead" title="Device type. ">MEMDevice::device_type</a>) get_banks – Returns the number of parallel memory banks get_bsize – Returns the size of one memory banks in bytes get_bits – Returns the width of the memory get_cols – Returns the number of SDRAM cols</p>
<h3>Functional <a class="el" href="classMemory.html" title="This class models a generic memory. Depending on the configuration it can be used as ROM...">Memory</a></h3>
<p>The storage handling of the GM is implementation dependent. The <a class="el" href="classMapStorage.html">MapStorage</a> uses a vmap, which can be either a std::map or a hash map with 32bit wide keys (addresses) and 8bit data entries. The <a class="el" href="classArrayStorage.html">ArrayStorage</a> uses a flat data array, with address being the index to the data elements. In all cases byte access to memory is performed using API functions: read, write, read_block, write_block, read_dbg, write_dbg, read_block_dbg, write_block_dbg. The *_dbg functions bypass the integrated statistic functions. The access functions are directly called from the b_transport method of the model. In case the <a class="el" href="structext__erase.html">ext_erase</a> payload extension is set, the respective memory region (start – end) is cleared using the erase (erase_dbg) function. This happens when switching SDRAM to Deep-Power-Down-Mode or Partial-Self-Refresh.</p>
<h2>Compilation</h2>
<p>The compilation of the GM is integrated in the build system of the library. An appropriate WAF wscript can be found next to the source files in the ./models/memory directory. All required objects for simulating the GM and the MCTRL are compiled in a sub-library named memory using following command: ./waf –target=memory To utilize the GM in simulations with other components, add memory to the use list of your wscript.</p>
<h2>Example Instantiation</h2>
<p>The example below demonstrates the instantiation of the GM as PROM, IO, SRAM and SDRAM (with <a class="el" href="classArrayStorage.html">ArrayStorage</a> and <a class="el" href="classMapStorage.html">MapStorage</a>). The modules are declared in lines 13-16 and created, within the constructor, in lines 30-36. Lines 44-47 show how to bind the bus target socket of the GM to the mem initiator socket of the MCTRL. </p><pre class="fragment">#include "core/common/systemc.h"
#include "memory.h"
#include "core/models/mctrl/mctrl.h"

class Top : public sc_module {
  public:

    // Memory controller
    Mctrl mctrl;

    // Generic memories
    Memory  rom;
    Memory  io;
    Memory  sram;
    Memory  sdram;

    ...

    // Constructor
    Top(sc_module_name mn) : sc_module(mn),

            ...

            // Initialize MCTRL
            mctrl("mctrl", romasel, sdrasel, romaddr, rommask, ioaddr, iomask,
                           ramaddr, rammask, paddr,   pmask,   wprot,  srbanks,
                           ram8,    ram16,   sepbus,  sdbits,  mobile, sden,
                    0, 0, 0, amba::amba_LT),
            // Initialize PROM
            rom("rom", MEMDevice::ROM, 2, 512 * 1024 * 1024 / 2, 32, 0, BaseMemory::MAP, false),
            // Initialize IO
            io("io", MEMDevice::IO, 1, 512 * 1024 * 1024, 32, 0, BaseMemory:MAP, false),
            // Initialize SRAM
            sram("sram", MEMDevice::SRAM, 4, 512 * 1024 * 1024 / 4, 32, 16, BaseMemory:ARRAYfalse),
            // Initialize SDRAM
            sdram("sdram", MEMDevice::SDRAM, 2, 512 * 1024 * 1024 / 2, 32, 16, BaseMemory::ARRAY, false) {

        ...

        // Set MCTRL timing for delay calculation
        mctrl.set_clk(10, SC_NS);

        // Connect MCTRL to Generic Memories
        mctrl.mem(rom.bus);
        mctrl.mem(io.bus);
        mctrl.mem(sram.bus);
        mctrl.mem(sdram.bus);</pre> </div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<footer>
  <div class="container">
    <div class="inner">
      <p>
        &nbsp; &copy; 
         <a href="http://www.tu-braunschweig.de/c3e">c3e - TU-Braunschweig</a>. 2012.
        All rights reserved. | <a href="impress.html">Impress</a> |
        Generated on Wed Oct 22 2014 14:14:42 for SoCRocket by &#160;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.7</a>
      </p>
    </div>
  </div>
</footer>
</body>
</html>

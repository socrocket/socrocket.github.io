<!-- HTML header for doxygen 1.8.8-->
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="generator" content="Doxygen 1.8.7">
    <meta name="author" content="meyer@c3e.cs.tu-bs.de">
    <title>SoCRocket: Modeling Concepts</title>
    <link href="tabs.css" rel="stylesheet" type="text/css">
    <link href="style-doxygen.css" rel="stylesheet" type="text/css" />
    <link href="bootstrap.min.css" rel="stylesheet" type="text/css">
    <link href="bootstrap-theme.min.css" rel="stylesheet" type="text/css">
    <script type="text/javascript" src="jquery.js"></script>
    <script type="text/javascript" src="bootstrap.min.js"></script>
    <script type="text/javascript" src="highlight.pack.js"></script>
    <script type="text/javascript" src="dynsections.js"></script>
    <script type="text/javascript" src="doxygen2bootstrap.js"></script>
    <link href="style.css" rel="stylesheet" type="text/css"/>
  </head>
  <body class="mainpage">
    <div class="container">
      <header class="jumbotron masthead">
        <div class="inner">
          <h1>
            <img alt="Logo" src="socrocket-logo.png"/>
            SoCRocket
          </h1>
          <p>Transaction-Level Modeling Framework for Space Applications</p>
        </div>
      </header>
    </div>
  <div class="container" id="top"><!-- do not remove this div, it is closed by doxygen! -->
<!-- end header part -->
<!-- Generated by Doxygen 1.8.7 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="usermanual.html">User Manual</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Modeling Concepts </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#modeling1">Coding Style</a><ul><li class="level2"><a href="#modeling1_1">Loosely Timed (LT)</a></li>
<li class="level2"><a href="#modeling1_2">Approximately Timed (AT)</a></li>
</ul>
</li>
<li class="level1"><a href="#modeling2">Library base classes</a></li>
<li class="level1"><a href="#modeling3">TLM Signal Communication Kit</a></li>
<li class="level1"><a href="#modeling4">Memory mapped registers</a></li>
<li class="level1"><a href="#modeling5">Power Modeling</a></li>
<li class="level1"><a href="#modeling6">RTL Co-Simulation Transactors</a><ul><li class="level2"><a href="#modeling6_1">AHB RTL Bus → TLM Slave</a></li>
<li class="level2"><a href="#modeling6_2">AHB RTL Master → TLM Bus</a></li>
<li class="level2"><a href="#modeling6_3">AHB TLM Bus → RTL Slave</a></li>
<li class="level2"><a href="#modeling6_4">AHB TLM Master → RTL Bus</a></li>
<li class="level2"><a href="#modeling6_5">APB TLM Bus → RTL Slave</a></li>
<li class="level2"><a href="#modeling6_6">TLM CPU → RTL Cache</a></li>
</ul>
</li>
<li class="level1"><a href="#modeling7">Extending the library</a></li>
</ul>
</div>
<div class="textblock"><dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>check and verify this document</dd></dl>
<p>In this chapter we describe the underlying modeling concepts of the library. This comprises coding style/abstraction, as well as common base classes and modeling techniques. The goal is to enable the user to extend the library by developing and integrating own modules.</p>
<h1><a class="anchor" id="modeling1"></a>
Coding Style</h1>
<p>The simulation models of the library are developed in SystemC language and build on the OSCI TLM2.0 standard. Like any TL model they abstract from cycle-timed accuracy by modeling communication in form of function calls. Depending on the use case this can be done in many different ways. The general aim is to save simulation time by sacrificing a certain amount of timing accuracy. Moreover, TL simulations usually give the user a bigger amount of leeway, compared to RTL.</p>
<p>Two major use cases are covered: software development and architecture exploration. Consequently, all IPs of the library support loosely timed (LT) and approximately timed (AT) abstraction. The abstraction layer is selected using constructor parameters.</p>
<h2><a class="anchor" id="modeling1_1"></a>
Loosely Timed (LT)</h2>
<p>The LT configuration of the simulation models is intendend for fast address-accurate simulation (SW development). Communication is modeled using blocking function calls and as little synchronization with the SystemC kernel as possible. Respectively, independent of the protocol, each data transmission completes in a single call to the TLM transport interface. The master stalls/blocks during the call. All involved transfer or target components increment the delay counter, which is carried along the payload. After return of control from the slave, the master may or may not consume the annotated delay. To reduce context switching the master is allowed to run ahead of time and to accumulate the delay of multiple transactions. LT models are supposed to provide ‘just enough’ timing accuracy to allow an operating system to boot.</p>
<h2><a class="anchor" id="modeling1_2"></a>
Approximately Timed (AT)</h2>
<p>The AT configuration of the simulation models is intendend for architecture exploration. To provide the required accuracy it models selected features of the involved communication protocols. This mainly relates to the pipelined nature of AHB. In the AHB protocol the data phase of a request and the address phase of a succeeding request may overlap. Ignoring this fact in simulations leads to large timing deviations. Nevertheless, the AT abstraction of the IPs in this library do not model the AHB protocol in a cycle-accurate way. The AT mode is supposed to provide a reasonable speedup over RTL simulation, while still being accurate enough to facilitate architectural decisions. This is achieved by describing all kinds of AHB transfers using four TLM phases (Table 4):</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 4 - AT Phase AHB Protocol</caption>
<tr id="HeadRow">
<th id="FirstColumn"></th><th id="MiddleColumn">Read Operation</th><th id="LastColumn">Write Operation </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">Begin of AHB address phase</td><td id="MiddleColumn"><code>tlm::BEGIN_REQ</code> (Master → Slave)</td><td id="LastColumn"><code>tlm::BEGIN_REQ</code> (Master → Slave) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">End of AHB address phase (incl. arbitration)</td><td id="MiddleColumn"><code>tlm::END_REQ</code> (Slave → Master)</td><td id="LastColumn"><code>tlm::END_REQ</code> (Slave → Master) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">Begin of AHB data phase</td><td id="MiddleColumn"><code>tlm::BEGIN_RESP</code> (Slave → Master)</td><td id="LastColumn"><code>amba::BEGIN_DATA</code> (Master → Slave) </td></tr>
<tr id="LastRow">
<td id="FirstColumn">End of AHB data phase</td><td id="MiddleColumn"><code>tlm::END_REQ</code> (Master → Slave)</td><td id="LastColumn"><code>amba::END_DATA</code> (Slave → Master) </td></tr>
</table>
<p>More information about the AT abstraction can be found in the respective section of the model descriptions (e.g. <a class="el" href="ahbctrl_p.html">AHBCtrl</a>, <a class="el" href="mctrl_p.html">MCTRL</a>, <a class="el" href="mmu_cache_p.html">mmu_cache</a>) and in <a class="el" href="interconnect_methodology.html">Interconnect Methodology</a>.</p>
<h1><a class="anchor" id="modeling2"></a>
Library base classes</h1>
<p>This section can be found here: <a class="el" href="common_doc.html">Library base classes</a></p>
<h1><a class="anchor" id="modeling3"></a>
TLM Signal Communication Kit</h1>
<p>This section can be found here: <a class="el" href="signalkit_doc.html">SoCRocket SignalKit</a></p>
<h1><a class="anchor" id="modeling4"></a>
Memory mapped registers</h1>
<p>GreenReg is used to model memory mapped registers throughout the library. Since almost every model requires a set of control registers, this unified scheme yields a high productivity gain. The following steps are required to define a register:</p>
<ol type="1">
<li>Include the GreenReg AMBA Socket header file. <div class="fragment"><div class="line"><span class="preprocessor">#include greenreg_ambasockets.h</span></div>
</div><!-- fragment --></li>
<li>Derive your class from GreenReg device <div class="fragment"><div class="line"><span class="keyword">class </span>foo : <span class="keyword">public</span> gs::reg::gr_device</div>
</div><!-- fragment --></li>
<li>Tell the system that your registers will require callback function (using the build-in macro). <div class="fragment"><div class="line">GC_HAS_CALLBACKS()</div>
</div><!-- fragment --></li>
<li>Create the socket the register is going to be connected to. <div class="fragment"><div class="line"><a class="code" href="classgs_1_1reg_1_1greenreg__socket.html">gs::reg::greenreg_socket&lt;gs::amba::amba_slave&lt;32&gt;</a> &gt; my_sock;</div>
</div><!-- fragment --></li>
<li>In the constructor of the module – initialize gr_device and socket. <div class="fragment"><div class="line"><span class="comment">// This will create a register bank of size bank_size bytes</span></div>
<div class="line">gr_device(<a class="code" href="namespacesetup.html#a61de3710bf6c9d78c0afa352263f8b09">name</a>, gs::reg::ALIGNED_ADDRESS, bank_size, NULL)</div>
</div><!-- fragment --></li>
<li>The initialization of gr_device (5) delivers a default pointer (r) to the newly generated memory bank. The initialization of the socket requires this pointer along the address settings for the bank as input arguments. <div class="fragment"><div class="line"><span class="comment">// Initialize socket and hook up register bank r</span></div>
<div class="line">my_sock(„sock“, <a class="code" href="satcan_8c.html#ae9180927c9b0d45c75dff89eb717b257">r</a>, <a class="code" href="grlib__tests_2prom_8S.html#a1652a4b8d4ecd86fdf714cee8ab67b00">start</a> address, end address, protocol (e.g. amba::amba_APB), abstraction (e.g. amba::amba_LT), <span class="keyword">false</span>)</div>
</div><!-- fragment --></li>
<li>Create a register within the new memory bank. <div class="fragment"><div class="line"><span class="comment">// New register in bank r at bank address + offset</span></div>
<div class="line"><a class="code" href="satcan_8c.html#ae9180927c9b0d45c75dff89eb717b257">r</a>.create_register(<a class="code" href="namespacesetup.html#a61de3710bf6c9d78c0afa352263f8b09">name</a>, <a class="code" href="namespacesetup.html#ade8aa54df2083113a10326ea2fe7934b">description</a>, <a class="code" href="engine_8c.html#ac289c24a4e248d19df57ec46beafa14e">offset</a>, type (e.g. gs::reg::STANDARD_REG), initial value, write mask, bit width, lock mask (not used))</div>
</div><!-- fragment --></li>
<li>Register a handler function for the register and make the handler sensitive to a register event. <div class="fragment"><div class="line">GR_FUNCTION(foo, my_handler);</div>
<div class="line">GR_SENSITIVE(<a class="code" href="satcan_8c.html#ae9180927c9b0d45c75dff89eb717b257">r</a>[<a class="code" href="engine_8c.html#ac289c24a4e248d19df57ec46beafa14e">offset</a>].add_rule(gs::reg::POST_WRITE, „scaler_write“, gs::reg::NOTIFY))</div>
</div><!-- fragment --></li>
<li>In this example the handler will be called after completion of a write operation (POST_WRITE). The signature of the handler function is void: <div class="fragment"><div class="line"><span class="keywordtype">void</span> my_handler()</div>
</div><!-- fragment --></li>
<li>A module that uses GreenReg registers needs to call the following macro in the destructor: <div class="fragment"><div class="line">GC_UNREGISTER_CALLBACKS</div>
</div><!-- fragment --></li>
</ol>
<p>Remark: All modules making use of GreenReg memory mapped registers must inherit from class <code>gr_device</code>. In the SoCRocket library this accounts for all IPs containing an APB slave interface (e.g. <code>MCTRL</code>, <code>IRQMP</code>, <code><a class="el" href="classGPTimer.html" title="This class is a TLM 2.0 Model of the Aeroflex Gaisler GRLIB GPTimer. Further informations to the orig...">GPTimer</a></code>, <code>SoCWire</code>.</p>
<h1><a class="anchor" id="modeling5"></a>
Power Modeling</h1>
<p>The SoCRocket library provides methods and tools for transaction level power estimation. All information on this topic has been summoned in the SoCRocket Power Modeling Report [RD11].</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000015">Todo:</a></b></dt><dd>where is the power modeling report?</dd></dl>
<h1><a class="anchor" id="modeling6"></a>
RTL Co-Simulation Transactors</h1>
<p>The library provides a set of RTL co-simulation transactors, which have been developed to facilitate the verification of the simulation IP. These transactors may also be used as a starting point for integrating other, third party, RTL IP in the system.</p>
<p>Regarding the AMBA interconnect the library provides 6 different TLM interfaces. It can be distinguished between master and slave components, AHB and APB components as well as bus and non-bus components.</p>
<ul>
<li>AHB TLM Master – The primary AHB master inferface; To be used for all AHB master components except busses; Can be found in MMU_CACHE and SoCWire IP.</li>
<li>AHB TLM Slave – The primary AHB slave interface; To be used for all AHB slave components except busses; Can be found in MCTRL, APBCTRL and AHBMEM.</li>
<li>AHB TLM Bus Master – The AHB master interface of the AHBCTRL (multi-socket); Stears the communication between bus and slave.</li>
<li>AHB TLM Bus Slave – The AHB slave interface of the AHBCTRL (multi-socket); All bus masters are to be bound to this interface.</li>
<li>APB TLM Master – The APB master interface of the APBCTRL (multi-socket)</li>
<li>APB TLM Slave – The APB slave interface; To be used for all APB slave components; Can be found in the MCTRL, IRQMP, <a class="el" href="classGPTimer.html" title="This class is a TLM 2.0 Model of the Aeroflex Gaisler GRLIB GPTimer. Further informations to the orig...">GPTimer</a> and SoCWire IPs.</li>
</ul>
<p>In general it has to be kept in mind that in AHB systems the communication protocols between master/bus, and bus/slave are different. This is reflected by the collection of transactors.</p>
<p>All type definitions for conversion between RTL and SystemC are summarized in the header <code>file ahb_adapter_types.h</code>.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000016">Todo:</a></b></dt><dd>does ahb_adapter_types.h still exist?</dd></dl>
<h2><a class="anchor" id="modeling6_1"></a>
AHB RTL Bus → TLM Slave</h2>
<p>Files: <code>ahb_rtlbus_tlmslave_transactor.{h,cpp}</code></p>
<p>The RTL Bus → TLM Slave transactor allows the GRLIB RTL AHBCTRL to be connected to SoCRocket AHB TLM Slaves. Within the library it is used in all co-simulation testbenches of the AHBCTRL IP.</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 5 - RTL Bus to TLM Slave transactor</caption>
<tr id="HeadRow">
<th id="FirstColumn">Socket name</th><th id="MiddleColumn">Type</th><th id="LastColumn">Description </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahbOUT</td><td id="MiddleColumn">amba_master_socket</td><td id="LastColumn">Bind to AHB TLM Slave </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahb_slv_in</td><td id="MiddleColumn">sc_in&lt;ahb_slv_in_type&gt;</td><td id="LastColumn">RTL input signals from slave to bus </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahb_slv_out</td><td id="MiddleColumn">sc_out&lt;ahb_slv_out_type&gt;</td><td id="LastColumn">RTL output signals from bus to slave </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">hirqi</td><td id="MiddleColumn">signal&lt;bool&gt;::infield</td><td id="LastColumn">IRQ signals from slave to bus </td></tr>
<tr id="LastRow">
<td id="FirstColumn">hirqo</td><td id="MiddleColumn">signal&lt;bool&gt;::selector</td><td id="LastColumn">IRQ signals from bus to slave </td></tr>
</table>
<h2><a class="anchor" id="modeling6_2"></a>
AHB RTL Master → TLM Bus</h2>
<p>Files: <code>ahb_rtlmaster_tlmbus_transactor.{h,cpp}</code></p>
<p>The RTL Master → TLM Bus transactor allows an AHB RTL master to be connected to the SoCRocket AHBCTRL IP. Within the library it is used in all co-simulation testbenches of the MMU_CACHE model.</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 6 - AHB RTL Master to TLM Bus transactor</caption>
<tr id="HeadRow">
<th id="FirstColumn">Socket name</th><th id="MiddleColumn">Type</th><th id="LastColumn">Description </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahbOUT</td><td id="MiddleColumn">amba_master_socket</td><td id="LastColumn">Bind to TLM AHBCTRL </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahb_mst_in</td><td id="MiddleColumn">sc_out&lt;ahb_master_in_type&gt;</td><td id="LastColumn">RTL output signals from bus to master </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahb_mst_out</td><td id="MiddleColumn">sc_in&lt;ahb_master_out_type&gt;</td><td id="LastColumn">RTL input signals from master to bus </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">hirqi</td><td id="MiddleColumn">signal&lt;bool&gt;::infield</td><td id="LastColumn">IRQ signals from master to bus </td></tr>
<tr id="LastRow">
<td id="FirstColumn">hirqo</td><td id="MiddleColumn">signal&lt;bool&gt;::selector</td><td id="LastColumn">IRQ signals from bus to master </td></tr>
</table>
<h2><a class="anchor" id="modeling6_3"></a>
AHB TLM Bus → RTL Slave</h2>
<p>Files: <code>ahb_tlmbus_rtlslave_transactor.{h,cpp}</code></p>
<p>The TLM Bus → RTL Slave transactor allows AHB RTL slaves to be connected to the SoCRocket AHBCTRL IP. Within the library it is used in several co-simulations of the MCTRL model.</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 7 - AHB TLM Bus to RTL Slave transactor</caption>
<tr id="HeadRow">
<th id="FirstColumn">Socket name</th><th id="MiddleColumn">Type</th><th id="LastColumn">Description </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahbIN</td><td id="MiddleColumn">amba_slave_socket</td><td id="LastColumn">Bind to TLM AHBCTRL </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahbsi</td><td id="MiddleColumn">sc_out&lt;ahb_slv_in_type&gt;</td><td id="LastColumn">RTL output signals from bus to slave </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahbso</td><td id="MiddleColumn">sc_in&lt;ahb_slv_out_type_adapter&gt;</td><td id="LastColumn">RTL input signals from slave to bus </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">hirqi</td><td id="MiddleColumn">signal&lt;bool&gt;::infield</td><td id="LastColumn">IRQ signals from slave to bus </td></tr>
<tr id="LastRow">
<td id="FirstColumn">hirqo</td><td id="MiddleColumn">signals&lt;bool&gt;::selector</td><td id="LastColumn">IRQ signals from bus to slave </td></tr>
</table>
<h2><a class="anchor" id="modeling6_4"></a>
AHB TLM Master → RTL Bus</h2>
<p>Files: <code>ahb_tlmmaster_rtlbus_transactor.{h,cpp}</code></p>
<p>The TLM Master → RTL Bus transactor allows SoCRocket AHB TLM masters to be connected to the GRLIB RTL AHBCTRL. Within the library it is used in all co-simulation testbenches of the AHBCTRL IP.</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 8 - AHB TLM Master to RTL Bus transactor</caption>
<tr id="HeadRow">
<th id="FirstColumn">Socket name</th><th id="MiddleColumn">Type</th><th id="LastColumn">Description </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahbIN</td><td id="MiddleColumn">amba_slave_socket</td><td id="LastColumn">Bind to TLM master (e.g. <a class="el" href="classmmu__cache.html" title="Top-level class of the memory sub-system for the TrapGen LEON3 simulator. ">mmu_cache</a>) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">snoop</td><td id="MiddleColumn">signal&lt;t_snoop&gt;</td><td id="LastColumn">snoop Snooping broadcast bus → masters </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahb_mst_in</td><td id="MiddleColumn">sc_in&lt;ahb_mst_in_type&gt;</td><td id="LastColumn">RTL input signals from bus to master (collected master outputs) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahb_mst_out</td><td id="MiddleColumn">sc_out&lt;ahb_mst_out_type_adapter&gt;</td><td id="LastColumn">RTL output signals from master to bus </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahb_slv_in</td><td id="MiddleColumn">sc_in&lt;ahb_slv_in_type&gt;</td><td id="LastColumn">RTL input signals from bus to master (collected slave outputs) </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">hirqi</td><td id="MiddleColumn">signal&lt;bool&gt;::infield</td><td id="LastColumn">IRQ signals from bus to master </td></tr>
<tr id="LastRow">
<td id="FirstColumn">hirqo</td><td id="MiddleColumn">signal&lt;bool&gt;::selector</td><td id="LastColumn">IRQ signals from master to bus </td></tr>
</table>
<h2><a class="anchor" id="modeling6_5"></a>
APB TLM Bus → RTL Slave</h2>
<p>Files: <code>apb_tlmbus_rtlslave_transactor.{h,cpp}</code></p>
<p>The APB TLM Bus → RTL Slave transactors allows GRLIB RTL APB slaves to be connected to the SoCRocket APBCTRL (AHB to APB bridge). Within the library it is used in various co-simulations of the MCTRL, the IRQMP and the <a class="el" href="classGPTimer.html" title="This class is a TLM 2.0 Model of the Aeroflex Gaisler GRLIB GPTimer. Further informations to the orig...">GPTimer</a>.</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 9 - APB TLM Bus to RTL Slave transactor</caption>
<tr id="HeadRow">
<th id="FirstColumn">Socket name</th><th id="MiddleColumn">Type</th><th id="LastColumn">Description </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">apbIN</td><td id="MiddleColumn">amba_slave_socket</td><td id="LastColumn">Bind to TLM APBCTRL </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">apbi</td><td id="MiddleColumn">sc_out&lt;apb_slv_in_type&gt;</td><td id="LastColumn">RTL output signals from bridge to slave </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">apbo</td><td id="MiddleColumn">sc_in&lt;apb_slv_out_type_adapter&gt;</td><td id="LastColumn">RTL input signals from slave to bridge </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">pirqi</td><td id="MiddleColumn">signal&lt;bool&gt;::infield</td><td id="LastColumn">IRQ signals from slave to bridge </td></tr>
<tr id="LastRow">
<td id="FirstColumn">pirqo</td><td id="MiddleColumn">signal&lt;bool&gt;::selector</td><td id="LastColumn">IRQ signals from bridge to slave </td></tr>
</table>
<h2><a class="anchor" id="modeling6_6"></a>
TLM CPU → RTL Cache</h2>
<p>Files: <code>tlmcpu_rtlcache_transactor.{h,cpp}</code></p>
<p>The TLM CPU → RTL Cache transactor differs from the remaining transactors of the library. It does not aim for connecting models to the AMBA backbone interconnect, but is dedicated to the verification of the MMU_CACHE IP.</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 10 - TLM CPU to RTL Cache transactor</caption>
<tr id="HeadRow">
<th id="FirstColumn">Socket name</th><th id="MiddleColumn">Type</th><th id="LastColumn">Description </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">icio</td><td id="MiddleColumn">simple_target_socket</td><td id="LastColumn">Bind to cpu instruction socket </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">dcio</td><td id="MiddleColumn">simple_target_socket</td><td id="LastColumn">Bind to cpu data socket </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ici</td><td id="MiddleColumn">sc_out&lt;icache_in_type&gt;</td><td id="LastColumn">RTL output signals from cpu to icache </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ico</td><td id="MiddleColumn">sc_in&lt;icache_out_type&gt;</td><td id="LastColumn">RTL input signals from icache to cpu </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">dci</td><td id="MiddleColumn">sc_out&lt;dcache_in_type&gt;</td><td id="LastColumn">RTL output signals from cpu to dcache </td></tr>
<tr id="LastRow">
<td id="FirstColumn">dco</td><td id="MiddleColumn">sc_in&lt;dcache_out_type&gt;</td><td id="LastColumn">RTL input signals from dcache to cpu </td></tr>
</table>
<p>The source code of all transactors is located in the ./adapters directory.</p>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000017">Todo:</a></b></dt><dd>isit?</dd></dl>
<p>The compilation of transactors is integrated in the SoCRocket build system: </p><pre class="fragment">$ ./waf –target=rtladapters
</pre><p>In order to utilize a RTL transactor in a platform simulation add the rtladapters target to the use line of your build script (wscript).</p>
<h1><a class="anchor" id="modeling7"></a>
Extending the library</h1>
<p>The SoCRocket library can be easily extended, by creating own components. The existing simulation models provide examples for almost all possible combinations of bus interfaces:</p>
<table  class="table table-striped table-hover">
<caption align="bottom">Table 11 - Overview models/interfaces</caption>
<tr id="HeadRow">
<th id="FirstColumn">Model</th><th id="LastColumn">Bus interfaces </th></tr>
<tr id="BodyRow">
<td id="FirstColumn">leon iss</td><td id="LastColumn">CPU instruction master, CPU data master, Interrupt slave </td></tr>
<tr id="BodyRow">
<td id="FirstColumn"><a class="el" href="classmmu__cache.html" title="Top-level class of the memory sub-system for the TrapGen LEON3 simulator. ">mmu_cache</a></td><td id="LastColumn">AHB master, CPU instruction slave, CPU data slave, Interrupt master, Snooping input </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahbctrl</td><td id="LastColumn">AHB master (multi-socket), AHB slave (multi-socket), Snooping output </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">apbctrl</td><td id="LastColumn">AHB slave, APB master </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">ahbmem</td><td id="LastColumn">AHB slave </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">mctrl</td><td id="LastColumn">AHB slave, APB slave </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">socwire</td><td id="LastColumn">AHB master, Interrupt master </td></tr>
<tr id="BodyRow">
<td id="FirstColumn">gptimer</td><td id="LastColumn">APB slave, Interrupt master </td></tr>
<tr id="LastRow">
<td id="FirstColumn">irqmp</td><td id="LastColumn">APB slave, Interrupt master (multi-socket), Interrupt slave (multi-socket) </td></tr>
</table>
<p>To be integrated in the SoCRocket platform infrastructure, new models have to fulfill certain requirements. Most of them are encapsulated in a set of base classes. A detailed description of these base classes can be found in <a class="el" href="common_doc.html">Library Base Classes</a>.</p>
<p>AHB Masters: All AHB master components must inherit from class <a class="el" href="classAHBMaster.html">AHBMaster</a>. <a class="el" href="classAHBMaster.html">AHBMaster</a> is derived from class <a class="el" href="classAHBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">AHBDevice</a> and template class <code>&lt;BASE&gt;</code>. <code>&lt;BASE&gt;</code> can be sc_module, which is the default case, or any other child of sc_module. <a class="el" href="classAHBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">AHBDevice</a> provides the interface for identification of the device in the system. At start_of_simulation the AHBCTRL reads the configuration records of all connected AHBDevices (Masters and Slaves) for building up its internal routing table (PNP records). The actual master socket, all related functionality, and state machines are encapsulated in class <a class="el" href="classAHBMaster.html">AHBMaster</a> iself.</p>
<p>The socket is defined as follows: </p><div class="fragment"><div class="line">amba_master_socket&lt;32&gt; ahb</div>
</div><!-- fragment --><p> The socket can be accessed via a set of interface functions (see <code>./models/utils/ahbmaster.h</code>). Use the following function for reading from the master socket: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ahbread(<a class="code" href="readpnp_8c.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> addr, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * data, <a class="code" href="readpnp_8c.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> len);</div>
</div><!-- fragment --><p> For writing data to the socket use: </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> ahbwrite(<a class="code" href="readpnp_8c.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> addr, <span class="keywordtype">unsigned</span> <span class="keywordtype">char</span> * data, <a class="code" href="readpnp_8c.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> len);</div>
</div><!-- fragment --><p> Other functions are available for using debug transport, activating bus locking, obtaining cacheability information, handing over additional delay, or retrieving a response pointer. The master can be configured for LT and AT abstraction via constructor parameter <code>ambaLayer</code>. At LT abstraction read-data can be obtained by evaluating the data pointer right after the interface returns control (blocking). At AT abstraction communication is non-blocking. This means, in a read operation the data pointer will usually not be valid right after return from the interface call. That’s why a callback function is provided for notifying the user about a valid response: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <span class="keywordtype">void</span> response_callback(tlm::tlm_generic_payload * <a class="code" href="fft_8c.html#a261dc6445544ab3a09e5f50b961887b5">trans</a>) {};</div>
</div><!-- fragment --><p> The response_callback function is plain virtual and must be implemented by the user.</p>
<p>AHB Slaves: AHB slave components must inherit from class <a class="el" href="classAHBSlave.html">AHBSlave</a>. <a class="el" href="classAHBSlave.html">AHBSlave</a> is derived from class <a class="el" href="classAHBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">AHBDevice</a> and template class <code>&lt;BASE&gt;</code>. <code>&lt;BASE&gt;</code> can be <code>sc_module</code>, which is the default case, or any other child of <code>sc_module</code>. Modules implementing memory mapped registers should set <code>&lt;BASE&gt;</code> to <code>gs::reg::gr_device</code> (Greenreg Device). <a class="el" href="classAHBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">AHBDevice</a> provides the interface for identification of the device in the system. At start_of_simulation the AHBCTRL reads the configuration records of all connected AHBDevices (Masters and Slaves) for building up its internal routing table (PNP records). The actual slave socket, all related functionality, and state machines are encapsulated in class <a class="el" href="classAHBSlave.html">AHBSlave</a> itself.</p>
<p>The socket is defined as follows: </p><div class="fragment"><div class="line">amba_slave_socket&lt;32&gt; ahb</div>
</div><!-- fragment --><p> Communication with the user class is implemented using a callback function: </p><div class="fragment"><div class="line"><span class="keyword">virtual</span> <a class="code" href="readpnp_8c.html#a435d1572bf3f880d55459d9805097f62">uint32_t</a> exec_func(tlm::tlm_generic_payload &amp;gp, sc_time &amp;delay, <span class="keywordtype">bool</span> <a class="code" href="namespacev.html#af32429aace6d7865e49ec226dfb811f9">debug</a> = <span class="keyword">false</span>) = 0;</div>
</div><!-- fragment --><p> The slave can be configured for LT and AT abstraction via constructor parameter ambaLayer. At LT abstraction exec_func is directly called from b_transport, and at AT abstraction directly after receiving BEGIN_REQ. The user model is expected to load the delay pointer with a response delay value! The response delay is the number of wait-states required for delivering the data multiplied with clock cycle time.</p>
<p>APB Slaves: All APB slaves must inherit from class <a class="el" href="classAPBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">APBDevice</a>. Similar to <a class="el" href="classAHBDevice.html" title="This class is a base class for grlib models. It implements the device plug and play informations...">AHBDevice</a> the conveyed information is used to set up the routing table of the <a class="el" href="classAPBCtrl.html">APBCtrl</a> (PNP records). If the new device is supposed to have memory mapped registers, it must inherit from class <code>gs::reg::gr_device</code>. A small guide for modeling registers with GreenReg can be found in section <a class="el" href="modeling.html#modeling4">Memory mapped registers</a>. To enable the connection of the clock, the module should also inherit from class <a class="el" href="classCLKDevice.html">CLKDevice</a>. </p><div class="fragment"><div class="line"><span class="keyword">class </span>my_apbcomponent : <span class="keyword">public</span> gs::reg::gr_device, <span class="keyword">public</span> <a class="code" href="classAPBDevice.html">APBDevice</a>, <span class="keyword">public</span> <a class="code" href="classCLKDevice.html">CLKDevice</a></div>
</div><!-- fragment --><p> <em>Note: Classes that inherit from gr_device must not inherit from sc_module!</em></p>
<p>CPU Master/Slave: Building a component that acts as a CPU or is directly connected to the CPU does not require any base class. However, the transactions generated by the CPU are supposed to carry certain payload extensions.</p>
<p>Instruction payload extensions: <code>icio_payload_extension.h</code></p>
<p>Data payload extensions: <code>dcio_payload_extension.h</code></p>
<p>Make sure to include the appropriate header/s in your design.</p>
<p>Interrupt Master/Slave: All models that send or receive interrupts must use the following macro: </p><div class="fragment"><div class="line"><a class="code" href="module_8h.html#ab8a07d08b477c3f6fdbe7d5129146292">SK_HAS_SIGNALS</a>(class_name)</div>
</div><!-- fragment --><p> For more information have a look at the <a class="el" href="signalkit_doc.html">SignalKit documentation</a>.   </p>
</div></div><!-- contents -->
<!-- HTML footer for doxygen 1.8.8-->
<!-- start footer part -->
<footer>
  <div class="container">
    <div class="inner">
      <p>
        &nbsp; &copy; 
         <a href="http://www.tu-braunschweig.de/c3e">c3e - TU-Braunschweig</a>. 2012.
        All rights reserved. | <a href="impress.html">Impress</a> |
        Generated on Mon Dec 1 2014 14:09:17 for SoCRocket by &#160;<a href="http://www.doxygen.org/index.html">Doxygen 1.8.7</a>
      </p>
    </div>
  </div>
</footer>
</body>
</html>
